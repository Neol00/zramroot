#!/bin/sh

# initramfs-tools hook script for zramroot

PREREQ=""

log_hook() {
    echo "zramroot hook: $@" >&2
}

log_debug() {
    if [ "${DEBUG_MODE}" = "yes" ]; then
        echo "zramroot hook-debug: $@" >&2
    fi
}

prereqs() {
    echo "$PREREQ"
}

case "$1" in
    prereqs)
        prereqs
        exit 0
        ;;
esac

# Source the initramfs hook functions
. /usr/share/initramfs-tools/hook-functions

# Parse config file for debug mode
DEBUG_MODE="no"
CONFIG_FILE="/etc/zramroot.conf"
if [ -f "${CONFIG_FILE}" ]; then
    # Extract DEBUG_MODE value - safer than sourcing the whole file
    debug_setting=$(grep "^DEBUG_MODE=" "${CONFIG_FILE}" | cut -d'"' -f2)
    if [ "${debug_setting}" = "yes" ]; then
        DEBUG_MODE="yes"
        log_hook "Debug mode enabled from config file"
    fi
fi

# --- Binaries needed by the boot script ---
log_hook "Copying necessary binaries..."

# Core utilities 
copy_bin_list="busybox sh mount umount mkdir rmdir echo cat grep sed df awk rsync cp touch date \
               mountpoint zramctl modprobe fsck blkid udevadm fuser find tail head ls sync \
               mkfs.ext4 fsck.ext4"

for bin in $copy_bin_list; do
    # Try to find the binary in common locations
    bin_path=""
    for dir in /bin /usr/bin /sbin /usr/sbin; do
        if [ -x "${dir}/${bin}" ]; then
            bin_path="${dir}/${bin}"
            break
        fi
    done
    
    if [ -n "${bin_path}" ]; then
        log_debug "Copying ${bin_path}"
        copy_exec "${bin_path}"
    else
        log_hook "Warning: Binary ${bin} not found!"
    fi
done

# Additional binaries that might be useful for debugging
debug_bin_list="lsmod ps dmesg free"
if [ "${DEBUG_MODE}" = "yes" ]; then
    for bin in $debug_bin_list; do
        for dir in /bin /usr/bin /sbin /usr/sbin; do
            if [ -x "${dir}/${bin}" ]; then
                log_debug "Copying debug binary ${dir}/${bin}"
                copy_exec "${dir}/${bin}"
                break
            fi
        done
    done
fi

# Filesystem related (Ensure all needed mkfs/fsck variants are included based on ZRAM_FS_TYPE)
# Get filesystem type from config
ZRAM_FS_TYPE="ext4" # Default
if [ -f "${CONFIG_FILE}" ]; then
    fs_type=$(grep "^ZRAM_FS_TYPE=" "${CONFIG_FILE}" | cut -d'"' -f2)
    if [ -n "${fs_type}" ]; then
        ZRAM_FS_TYPE="${fs_type}"
        log_hook "Found filesystem type in config: ${ZRAM_FS_TYPE}"
    fi
fi

log_hook "Copying filesystem tools for ${ZRAM_FS_TYPE}..."
# Always include ext4 as it's the default/fallback
copy_exec /sbin/mkfs.ext4 /sbin
copy_exec /sbin/fsck.ext4 /sbin

# Add specific filesystem tools based on configuration
case "${ZRAM_FS_TYPE}" in
    btrfs)
        if [ -x /sbin/mkfs.btrfs ]; then
            log_debug "Copying btrfs tools"
            copy_exec /sbin/mkfs.btrfs /sbin
            copy_exec /sbin/btrfs /sbin
        else
            log_hook "Warning: btrfs tools not found but btrfs selected!"
        fi
        ;;
    xfs)
        if [ -x /sbin/mkfs.xfs ]; then
            log_debug "Copying xfs tools"
            copy_exec /sbin/mkfs.xfs /sbin
            copy_exec /sbin/xfs_repair /sbin
        else
            log_hook "Warning: xfs tools not found but xfs selected!"
        fi
        ;;
esac

# Always include fsck
copy_exec /sbin/fsck /sbin

# --- Kernel Modules ---
log_hook "Adding required kernel modules..."

# Add the zram module using the standard mechanism
log_hook "Adding zram module..."
manual_add_modules zram

# Add filesystem modules
log_hook "Adding filesystem modules..."
manual_add_modules ext4   # Always include ext4 as fallback

# Add other filesystems based on configuration
case "${ZRAM_FS_TYPE}" in
    btrfs)
        log_debug "Adding btrfs module"
        manual_add_modules btrfs
        ;;
    xfs)
        log_debug "Adding xfs module"
        manual_add_modules xfs
        ;;
esac

# Get compression algorithm from config
ZRAM_ALGO="zstd" # Default
if [ -f "${CONFIG_FILE}" ]; then
    algo=$(grep "^ZRAM_ALGO=" "${CONFIG_FILE}" | cut -d'"' -f2)
    if [ -n "${algo}" ]; then
        ZRAM_ALGO="${algo}"
        log_hook "Found compression algorithm in config: ${ZRAM_ALGO}"
    fi
fi

# Add compression modules based on algorithm
log_hook "Adding compression modules for algorithm: ${ZRAM_ALGO}..."
case "${ZRAM_ALGO}" in
    zstd)
        log_debug "Adding zstd module"
        manual_add_modules zstd
        ;;
    lz4)
        log_debug "Adding lz4 module"
        manual_add_modules lz4
        ;;
    lzo)
        log_debug "Adding lzo module"
        manual_add_modules lzo
        ;;
    *)
        log_hook "Adding all compression modules for compatibility"
        manual_add_modules zstd
        manual_add_modules lz4
        manual_add_modules lzo
        ;;
esac

# Add extra modules
EXTRA_MODULES="efi_pstore dmi_sysfs socinfo arm_smccc_trng reboot_mode fixed gpio_keys input_leds joydev uio uio_pdrv_genirq ocmem qcom_common qcom_sysmon qcom_glink_smem qcom_cpucp_mbox qcom_q6v5_mss qcom_q6v5 qcom_q6v5_pas qcom_pil_info qcom_spmi_pmic qcom_spmi_temp_alarm qcom_battmgr qcom_stats qcom_edac qcom_pon pm8941_pwrkey rtc_pm8xxx pwrseq_core pwrseq_qcom_wcn qrtr qrtr_smd qrtr_mhi rpmsg_ctrl ucsi_glink icc_bwmon btrfs blake2b_generic xor xor_neon raid6_pq autofs4 nvme_core nvme nvme_auth nf_defrag_ipv4 nf_defrag_ipv6 nf_conntrack nf_nat nfnetlink nft_tables udp_tunnel ip6_udp_tunnel ip_tables x_tables nft_ct nft_masq nft_reject nf_reject_ipv4 nf_reject_ipv6 nft_reject_inet nft_chain_nat sch_fq_codel ip_set aes_ce_cipher aes_ce_blk aes_ce_ccm sha1_ce sha256_arm64 sha2_ce sha3_ce sm3 sm3_ce sm4 sm4_ce sm4_ce_cipher sm4_ce_ccm sm4_ce_gcm ghash_ce polyval_generic polyval_ce michael_mic af_alg algif_skcipher algif_hash libarc4 cfg80211 mac80211 bluetooth btbcm btrtl btqca bnep rfcomm typec_ucsi i2c_qcom_geni i2c_hid i2c_hid_of hid hid_generic hid_multitouch snd snd_timer snd_pcm snd_seq_device snd_rawmidi snd_seq snd_seq_midi_event snd_seq_midi snd_compress snd_pcm_dmaengine snd_soc_core ac97_bus soundcore industrialio apr snd_q6apm q6prm q6prm_clocks snd_q6dsp_common q6apm_dai q6apm_lpass_dais snd_soc_lpass_macro_common snd_soc_lpass_rx_macro snd_soc_lpass_tx_macro snd_soc_lpass_wsa_macro snd_soc_lpass_va_macro snd_soc_hdmi_codec lpasscc_sc8280xp pinctrl_lpass_lpi drm_exec gpu_sched msm pci_pwrctrl_core pci_pwrctrl_pwrseq phy_qcom_edp phy_nxp_ptn3222 ps883x tcsrcc_x1e80100 gpucc_x1e80100 dispcc_x1e80100 panel_samsung_atna33xc20 libcurve25519_generic libchacha libchacha20poly1305 chacha_neon poly1305_neon"

log_hook "Adding Extra modules: ${EXTRA_MODULES}"
for module in ${EXTRA_MODULES}; do
    log_debug "Adding module: ${module}"
    manual_add_modules "${module}"
done

# --- Configuration File ---
log_hook "Copying configuration file..."
CONFIG_SOURCE="/etc/zramroot.conf"
CONFIG_ALT_SOURCE="/usr/share/initramfs-tools/conf.d/zramroot-config" # Alternative path
CONFIG_DEST="${DESTDIR}/conf/zramroot-config" # Path in initramfs

mkdir -p "${DESTDIR}/conf"

if [ -f "${CONFIG_SOURCE}" ]; then
    cp "${CONFIG_SOURCE}" "${CONFIG_DEST}"
    log_hook "Configuration file copied from ${CONFIG_SOURCE} to ${CONFIG_DEST}"
    
    # Log config file content in debug mode
    if [ "${DEBUG_MODE}" = "yes" ]; then
        log_debug "Configuration file content:"
        cat "${CONFIG_SOURCE}" | while read line; do
            log_debug "CONFIG: $line"
        done
    fi
elif [ -f "${CONFIG_ALT_SOURCE}" ]; then
    cp "${CONFIG_ALT_SOURCE}" "${CONFIG_DEST}"
    log_hook "Configuration file copied from ${CONFIG_ALT_SOURCE} to ${CONFIG_DEST}"
    
    # Log config file content in debug mode
    if [ "${DEBUG_MODE}" = "yes" ]; then
        log_debug "Configuration file content:"
        cat "${CONFIG_ALT_SOURCE}" | while read line; do
            log_debug "CONFIG: $line"
        done
    fi
else
    log_hook "Configuration file not found! Creating a default one in ${CONFIG_DEST}."
    # Create default config file
    cat > "${CONFIG_DEST}" << EOF
# Default configuration for ZRAM Root Boot
DEBUG_MODE="no"
ZRAM_SIZE_MiB=0
ZRAM_ALGO="lz4"
ZRAM_FS_TYPE="ext4"
ZRAM_MOUNT_OPTS="rw,noatime"
RAM_MIN_FREE_MiB=512
RAM_PREF_FREE_MiB=512
ZRAM_MIN_FREE_MiB=256
ZRAM_MAX_FREE_MiB=35840
ESTIMATED_COMPRESSION_RATIO=2.5
ZRAM_BUFFER_PERCENT=10
ZRAM_DEVICE_NUM=0
TRIGGER_PARAMETER="zramroot"
WAIT_TIMEOUT=3
EOF
    log_debug "Created default configuration file"
fi

# Create required directories for mounting
mkdir -p "${DESTDIR}/zram_root"
mkdir -p "${DESTDIR}/local_root"

# --- Boot Script ---
log_hook "Copying main boot script..."
BOOT_SCRIPT_SOURCE="/usr/share/initramfs-tools/scripts/local-premount/zramroot-boot"
BOOT_SCRIPT_DEST="${DESTDIR}/scripts/local-premount/zramroot-boot"

if [ -f "${BOOT_SCRIPT_SOURCE}" ]; then
    # Ensure the target directory exists
    mkdir -p "${DESTDIR}/scripts/local-premount"
    # Copy the script and make it executable
    cp "${BOOT_SCRIPT_SOURCE}" "${BOOT_SCRIPT_DEST}"
    chmod +x "${BOOT_SCRIPT_DEST}"
    log_hook "Boot script copied to ${BOOT_SCRIPT_DEST}"
    
    # Verify script was copied correctly
    if [ ! -x "${BOOT_SCRIPT_DEST}" ]; then
        log_hook "Warning: Boot script may not be executable!"
        ls -la "${BOOT_SCRIPT_DEST}"
    fi
else
    log_hook "Error: Boot script ${BOOT_SCRIPT_SOURCE} not found!"
    exit 1
fi

# --- Verify Local Script ---
LOCAL_SCRIPT_SOURCE="/usr/share/initramfs-tools/scripts/local"
LOCAL_SCRIPT_DEST="${DESTDIR}/scripts/local"

if [ -f "${LOCAL_SCRIPT_SOURCE}" ]; then
    log_hook "Verifying local script..."
    
    # Check if local script has zramroot support
    if grep -q "zramroot" "${LOCAL_SCRIPT_SOURCE}"; then
        log_hook "Local script has zramroot support"
    else
        log_hook "Warning: Local script may not have zramroot support!"
        # Copy our version if we have one
        if [ -f "/usr/share/initramfs-tools/scripts/local.zramroot" ]; then
            log_hook "Using our enhanced local script"
            cp "/usr/share/initramfs-tools/scripts/local.zramroot" "${LOCAL_SCRIPT_DEST}"
            chmod +x "${LOCAL_SCRIPT_DEST}"
        fi
    fi
else
    log_hook "Warning: Cannot verify local script - not found at ${LOCAL_SCRIPT_SOURCE}"
fi

log_hook "zramroot hook finished successfully."
exit 0
