#!/bin/busybox sh
# initramfs-zramroot-boot

# --- Global Variables ---
CONFIG_FILE="/conf/zramroot-config" 
DEBUG_MODE="no" # Will be loaded from config
REAL_ROOT_DEVICE="" # Will be set from ROOT environment variable
REAL_ROOT_MNT="/mnt/real_root_rw"  # For persistent logging and copying
DATE_TIME=$(date '+%m-%d-%H%M' 2>/dev/null || echo "unknown") # Generate log filename with date/time
REAL_ROOT_LOG_DIR="${REAL_ROOT_MNT}/var/log"
REAL_ROOT_LOG_FILE="${REAL_ROOT_LOG_DIR}/zramroot-${DATE_TIME}.log"
ZRAM_DEVICE="zram0"
TRIGGER_PARAMETER="zramroot" # Default trigger word
WAIT_TIMEOUT=3 # Seconds to wait for the real root device
ZRAM_DEVICE_NUM=0
ZRAM_SIZE_MiB=0
ZRAM_ALGO="lz4"
ZRAM_FS_TYPE="ext4"
ZRAM_MOUNT_OPTS="rw,noatime"
RAM_MIN_FREE_MiB=512   # Minimum RAM to leave free after ZRAM allocation
ZRAM_MIN_FREE_MiB=256   # Minimum ZRAM to leave free for growth
RAM_PREF_FREE_MiB=512  # Preferred RAM to leave free
ZRAM_MAX_FREE_MiB=35840  # Maximum ZRAM to leave free for growth
ESTIMATED_COMPRESSION_RATIO=2.5
ZRAM_BUFFER_PERCENT=10
BOOT_ID=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")

# Use a temporary mount point in /tmp
ZRAM_TEMP_MNT="/tmp/zram_temp"

# --- Logging Functions ---
log_kernel() { 
    echo "zramroot: $@" > /dev/kmsg 2>/dev/null || true
}

log_debug() {
    if [ "${DEBUG_MODE}" = "yes" ]; then
        log_kernel "DEBUG: $@"
    fi
}

log_error() {
    log_kernel "ERROR: $@"
}

# Check if zramroot parameter is in cmdline before doing anything
log_kernel "Checking for zramroot parameter in kernel cmdline"
if ! echo " $(cat /proc/cmdline) " | grep -q "[[:space:]]zramroot[[:space:]]"; then
    log_debug "No zramroot parameter found - exiting quietly"
    exit 0
fi

log_kernel "zramroot parameter found - starting setup"

# Create necessary directories
mkdir -p /mnt
mkdir -p /tmp
mkdir -p "${ZRAM_TEMP_MNT}"

# Try to mount physical root for logging (don't fail if this doesn't work)
REAL_ROOT_DEVICE="${ROOT}"
if [ -n "${REAL_ROOT_DEVICE}" ]; then
    log_debug "Attempting to mount physical root ${REAL_ROOT_DEVICE} for logging"
    mkdir -p "${REAL_ROOT_MNT}"
    
    # Try to find the real device
    real_dev=""
    if command -v blkid >/dev/null 2>&1; then
        real_dev=$(blkid -l -t "${REAL_ROOT_DEVICE}" -o device 2>/dev/null)
    fi
    
    if [ -z "$real_dev" ] && [ "${REAL_ROOT_DEVICE#/dev/}" != "${REAL_ROOT_DEVICE}" ] && [ -b "${REAL_ROOT_DEVICE}" ]; then
        real_dev="${REAL_ROOT_DEVICE}"
    fi
    
    if [ -n "$real_dev" ] && [ -b "$real_dev" ]; then
        if mount -o rw "$real_dev" "${REAL_ROOT_MNT}" 2>/dev/null; then
            mkdir -p "${REAL_ROOT_LOG_DIR}"
            log_debug "Physical root mounted for logging at ${REAL_ROOT_MNT}"
        fi
    fi
fi

# Load configuration
DEBUG_MODE="no"; ZRAM_SIZE_MiB=0; ZRAM_ALGO="zstd"; ZRAM_FS_TYPE="ext4"
ZRAM_MOUNT_OPTS="defaults,noatime"; RAM_MIN_FREE_MiB=512
ZRAM_BUFFER_PERCENT=10
ZRAM_DEVICE_NUM=0; TRIGGER_PARAMETER="zramroot"; WAIT_TIMEOUT=3
RAM_PREF_FREE_MiB=1024; ZRAM_MIN_FREE_MiB=256; ZRAM_MAX_FREE_MiB=35840

if [ -f "${CONFIG_FILE}" ]; then
    log_debug "Loading configuration from ${CONFIG_FILE}"
    . "${CONFIG_FILE}"
fi

# Set algorithm-specific compression estimates based on empirical testing
# These are not user-configurable as ZRAM doesn't allow tuning compression levels
case "${ZRAM_ALGO}" in
    "zstd")
        ESTIMATED_COMPRESSION_RATIO=3.0  # Conservative estimate for zstd
        ;;
    "lz4hc")
        ESTIMATED_COMPRESSION_RATIO=2.5  # Better compression than lz4
        ;;
    "lz4")
        ESTIMATED_COMPRESSION_RATIO=2.0  # Fast but moderate compression
        ;;
    "lzo"|"lzo-rle")
        ESTIMATED_COMPRESSION_RATIO=1.8  # Fastest, but least compression
        ;;
    *)
        ESTIMATED_COMPRESSION_RATIO=2.2  # Safe default for unknown algorithms
        ;;
esac

log_debug "Using compression ratio estimate of ${ESTIMATED_COMPRESSION_RATIO} for algorithm ${ZRAM_ALGO}"

ZRAM_DEVICE="/dev/zram${ZRAM_DEVICE_NUM}"

log_kernel "=== STARTING ZRAM ROOT SETUP PROCESS ==="

# Check available RAM
AVAILABLE_RAM_KB=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
if [ -z "$AVAILABLE_RAM_KB" ]; then
    AVAILABLE_RAM_KB=$(grep MemFree /proc/meminfo | awk '{print $2}')
fi

if ! echo "$AVAILABLE_RAM_KB" | grep -q '^[0-9]\+$'; then
    log_error "Cannot determine available RAM. Cannot proceed."
    exit 1
fi

AVAILABLE_RAM_MiB=$((AVAILABLE_RAM_KB / 1024))
log_debug "Available RAM: ${AVAILABLE_RAM_MiB} MiB"

# Calculate used size of physical root
if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
    ROOT_USED_KB=$(LC_ALL=POSIX df -k "${REAL_ROOT_MNT}" | awk 'NR==2 {print $3}')
    if ! echo "$ROOT_USED_KB" | grep -q '^[0-9]\+$'; then
        log_error "Could not determine used disk space on ${REAL_ROOT_MNT}."
        exit 1
    fi
    ROOT_USED_MiB=$((ROOT_USED_KB / 1024))
else
    # Fallback: estimate 4GB if we can't mount physical root
    ROOT_USED_MiB=4096
    log_debug "Could not mount physical root, estimating 4GB"
fi

log_kernel "Used size on physical root: ${ROOT_USED_MiB} MiB"

# Add buffer to root usage
BUFFER_MiB=$(awk -v u="$ROOT_USED_MiB" -v p="$ZRAM_BUFFER_PERCENT" 'BEGIN{printf "%.0f", u * p / 100}')
ROOT_WITH_BUFFER_MiB=$((ROOT_USED_MiB + BUFFER_MiB))

# Calculate expected compressed size using compression ratio
# This is the key fix: we need to account for compression when sizing ZRAM
EXPECTED_COMPRESSED_ROOT_MiB=$(awk -v r="$ROOT_WITH_BUFFER_MiB" -v c="$ESTIMATED_COMPRESSION_RATIO" 'BEGIN{printf "%.0f", r / c}')
log_kernel "Expected compressed size: ${EXPECTED_COMPRESSED_ROOT_MiB} MiB (ratio: ${ESTIMATED_COMPRESSION_RATIO})"

# Determine ZRAM size
if [ "$ZRAM_SIZE_MiB" -gt 0 ]; then
    FINAL_ZRAM_SIZE_MiB=$ZRAM_SIZE_MiB
    log_kernel "Using configured ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
else
    # Calculate dynamically based on compressed size
    if [ $((AVAILABLE_RAM_MiB - RAM_MIN_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
        log_error "Insufficient RAM: Available ${AVAILABLE_RAM_MiB} MiB < Needed $((RAM_MIN_FREE_MiB + EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB)) MiB."
        exit 1
    fi
    
    if [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB))
        log_kernel "RAM is tight: Using minimum ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    elif [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MAX_FREE_MiB)) -le 0 ]; then
        EXTRA_ZRAM=$((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB))
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + EXTRA_ZRAM))
        log_kernel "Medium RAM availability: Using ${FINAL_ZRAM_SIZE_MiB} MiB for ZRAM"
    else
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MAX_FREE_MiB))
        log_kernel "Plenty of RAM: Using maximum ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    fi
    
    # Additional safety check: ensure ZRAM size is reasonable
    # ZRAM size should be at least the compressed size or we risk running out of space
    MIN_SAFE_ZRAM=$((EXPECTED_COMPRESSED_ROOT_MiB + (EXPECTED_COMPRESSED_ROOT_MiB / 4)))  # Add 25% safety margin
    if [ "$FINAL_ZRAM_SIZE_MiB" -lt "$MIN_SAFE_ZRAM" ]; then
        log_kernel "Adjusting ZRAM size to safe minimum: ${MIN_SAFE_ZRAM} MiB (was ${FINAL_ZRAM_SIZE_MiB} MiB)"
        FINAL_ZRAM_SIZE_MiB=$MIN_SAFE_ZRAM
    fi
fi

# Load zram module if not already loaded
if ! lsmod | grep -q '^zram '; then
    log_debug "Loading zram kernel module..."
    modprobe zram || {
        log_error "Failed to load zram kernel module!"
        exit 1
    }
fi

# Wait for ZRAM device node to appear
sleep 3
if command -v udevadm >/dev/null && [ -x "$(command -v udevadm)" ]; then
    udevadm settle || log_debug "udev settle failed or not available"
fi

# Check if ZRAM device exists, if not create/configure it
if [ ! -b "${ZRAM_DEVICE}" ]; then
    # Try using zramctl if available
    if command -v zramctl >/dev/null; then
        log_debug "Using zramctl to create ZRAM device..."
        if zramctl --find --size "${FINAL_ZRAM_SIZE_MiB}M" --algorithm "${ZRAM_ALGO}" >/dev/null 2>&1; then
            ZRAM_DEVICE=$(zramctl --output NAME --noheadings | head -1)
            log_debug "Created ZRAM device: ${ZRAM_DEVICE}"
        else
            log_debug "zramctl failed, trying manual approach..."
            # Fall back to manual configuration
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        fi
    else
        # No zramctl, try manual configuration
        log_debug "zramctl not available, using manual configuration..."
        echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
        echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
    fi
else
    # Device exists, check if it's configured
    if [ -f "/sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize" ]; then
        current_size=$(cat /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null || echo "0")
        if [ "$current_size" = "0" ]; then
            log_debug "ZRAM device exists but not configured, configuring now..."
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        else
            log_debug "ZRAM device already configured"
        fi
    fi
fi

# Wait a bit more for device to be ready
sleep 2

# Verify ZRAM device exists
if [ ! -b "${ZRAM_DEVICE}" ]; then
    log_error "ZRAM device does not exist after configuration!"
    exit 1
fi

log_debug "ZRAM device configured successfully"

# Format ZRAM filesystem
log_kernel "Formatting ZRAM device with ${ZRAM_FS_TYPE} filesystem..."
mkfs_cmd="mkfs.${ZRAM_FS_TYPE}"
mkfs_opts=""

if ! command -v ${mkfs_cmd} >/dev/null; then
    log_error "Filesystem utility ${mkfs_cmd} not found in initramfs!"
    exit 1
fi

# Add specific options for filesystem types
if [ "$ZRAM_FS_TYPE" = "ext4" ]; then 
    mkfs_opts="-F"
elif [ "$ZRAM_FS_TYPE" = "btrfs" ]; then
    mkfs_opts="-f"
fi

if ${mkfs_cmd} ${mkfs_opts} "${ZRAM_DEVICE}" >/dev/null 2>&1; then
    log_kernel "ZRAM device formatted successfully"
else
    log_error "Failed to format ZRAM device!"
    exit 1
fi

# Now mount ZRAM temporarily and copy files
mkdir -p "${ZRAM_TEMP_MNT}"
if mount -t "${ZRAM_FS_TYPE}" -o "rw,${ZRAM_MOUNT_OPTS}" "${ZRAM_DEVICE}" "${ZRAM_TEMP_MNT}"; then
    log_debug "ZRAM device mounted at ${ZRAM_TEMP_MNT}"
    
    # Copy filesystem from physical root to ZRAM ONLY if we successfully mounted physical root
    if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
        log_kernel "Copying root filesystem from ${REAL_ROOT_MNT} to ZRAM..."
        
        # Define rsync command with exclusions
        RSYNC_EXCLUDE="--exclude=/dev/* --exclude=/proc/* --exclude=/sys/* --exclude=/tmp/* --exclude=/run/* --exclude=/mnt/* --exclude=/media/* --exclude=/lost+found --exclude=/var/log/journal/*"
        RSYNC_CMD="rsync -ax --delete ${RSYNC_EXCLUDE} ${REAL_ROOT_MNT}/ ${ZRAM_TEMP_MNT}/"
        
        if eval "${RSYNC_CMD}" >/dev/null 2>&1; then
            log_kernel "Filesystem copy completed successfully"
            
            # Create required directories in ZRAM root
            for dir in dev proc sys run tmp; do
                mkdir -p "${ZRAM_TEMP_MNT}/${dir}"
                chmod 755 "${ZRAM_TEMP_MNT}/${dir}"
            done
            
            # Modify /etc/fstab in ZRAM root
            if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
                cp "${ZRAM_TEMP_MNT}/etc/fstab" "${ZRAM_TEMP_MNT}/etc/fstab.zram_backup"
                sed -i -E "s|^([^#].*\s+/\s+.*)$|# ZRAMROOT: \1|g" "${ZRAM_TEMP_MNT}/etc/fstab"
                sed -i -E "s|^([^#].*\s+(/boot|/boot/efi|/home|/var)\s+.*)$|# ZRAMROOT: \1|g" "${ZRAM_TEMP_MNT}/etc/fstab"
            fi
        else
            log_error "Rsync failed to copy files from physical root to ZRAM!"
            exit 1
        fi
    else
        log_debug "Physical root not mounted, assuming ZRAM already has filesystem"
    fi
    
    # Sync and unmount
    sync
    sleep 1
    umount "${ZRAM_TEMP_MNT}" || {
        log_error "Failed to unmount ZRAM root!"
        exit 1
    }
    log_debug "ZRAM root unmounted successfully"
else
    log_error "Failed to mount ZRAM device for file copy!"
    exit 1
fi

# Calculate final mount options
final_mount_opts=$(echo "${ZRAM_MOUNT_OPTS},rw" | sed 's/,defaults//g; s/,ro//g; s/,rw,rw/,rw/g; s/^,\|,$//g')
[ -z "$final_mount_opts" ] && final_mount_opts="rw"

# Export ZRAM variables for use by the local script
log_kernel "Setting ZRAMROOT Variables..."
export ZRAMROOT_DEVICE="${ZRAM_DEVICE}"
export ZRAMROOT_FSTYPE="${ZRAM_FS_TYPE}"
export ZRAMROOT_ROOTFLAGS="${final_mount_opts}"

mkdir -p /conf
echo "ZRAMROOT_DEVICE=${ZRAM_DEVICE}" > /conf/zramroot_vars
echo "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}" >> /conf/zramroot_vars
echo "ZRAMROOT_ROOTFLAGS=${final_mount_opts}" >> /conf/zramroot_vars
chmod 644 /conf/zramroot_vars

# Also write to tmp as backup
echo "ZRAMROOT_DEVICE=${ZRAM_DEVICE}" > /tmp/zramroot_vars
echo "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}" >> /tmp/zramroot_vars
echo "ZRAMROOT_ROOTFLAGS=${final_mount_opts}" >> /tmp/zramroot_vars

log_kernel "ZRAMROOT_DEVICE=${ZRAM_DEVICE}"
log_kernel "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}"
log_kernel "ZRAMROOT_ROOTFLAGS=${final_mount_opts}"

# Cleanup physical root mount if we mounted it
if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
    log_debug "Unmounting physical root"
    sync
    umount "${REAL_ROOT_MNT}" || umount -l "${REAL_ROOT_MNT}" || true
fi

log_kernel "===== ZRAM ROOT PREPARATION SCRIPT FINISHED SUCCESSFULLY ====="
exit 0
