#!/bin/busybox sh
# initramfs-zramroot-boot

# --- Global Variables ---
CONFIG_FILE="/conf/zramroot-config" 
DEBUG_MODE="no" # Will be loaded from config
DEBUG_LOG_DIR="/var/log"
DEBUG_LOG_DEVICE=""
REAL_ROOT_DEVICE="" # Will be set from ROOT environment variable
REAL_ROOT_MNT="/mnt/real_root_rw"  # For persistent logging and copying
DATE_TIME=$(date '+%Y%m%d-%H%M%S' 2>/dev/null || echo "unknown") # Generate log filename with date/time
REAL_ROOT_LOG_DIR="${REAL_ROOT_MNT}${DEBUG_LOG_DIR}"
REAL_ROOT_LOG_FILE="${REAL_ROOT_LOG_DIR}/zramroot-${DATE_TIME}.log"
ZRAM_DEVICE="zram0"
TRIGGER_PARAMETER="zramroot" # Default trigger word
WAIT_TIMEOUT=120 # Seconds to wait for the real root device
ZRAM_DEVICE_NUM=0
ZRAM_SIZE_MiB=0
ZRAM_ALGO="lz4"
ZRAM_FS_TYPE="ext4"
ZRAM_MOUNT_OPTS="noatime"
RAM_MIN_FREE_MiB=512   # Minimum RAM to leave free after ZRAM allocation
ZRAM_MIN_FREE_MiB=256   # Minimum ZRAM to leave free for growth
RAM_PREF_FREE_MiB=1024  # Preferred RAM to leave free
ZRAM_MAX_FREE_MiB=35840  # Maximum ZRAM to leave free for growth
ESTIMATED_COMPRESSION_RATIO=2.5
ZRAM_BUFFER_PERCENT=10
BOOT_ID=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")
ZRAM_TEMP_MNT="/zram_root" # Temporary mount point for ZRAM (consistent across all implementations)

# --- Enhanced Logging Functions ---
log_kernel() { 
    echo "zramroot: $@" > /dev/kmsg 2>/dev/null || true
}

log_debug() {
    if [ "${DEBUG_MODE}" = "yes" ]; then
        log_kernel "DEBUG: $@"
        # Also log to physical drive if mounted and writable
        if [ -w "${REAL_ROOT_LOG_FILE}" ]; then
            now=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
            echo "${now} ZRAMROOT-BOOT DEBUG: $@" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
        fi
    fi
}

log_error() {
    log_kernel "ERROR: $@"
    # Always log errors to physical drive if available
    if [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        now=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
        echo "${now} ZRAMROOT-BOOT ERROR: $@" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

log_info() {
    log_kernel "$@"
    # Log info messages to physical drive if debug mode is on
    if [ "${DEBUG_MODE}" = "yes" ] && [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        now=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
        echo "${now} ZRAMROOT-BOOT INFO: $@" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

# --- Progress Bar Functions ---
# Terminal control sequences
ESC='\033'
CLEAR_LINE="${ESC}[2K\r"
MOVE_UP="${ESC}[1A"
GREEN="${ESC}[0;32m"
YELLOW="${ESC}[1;33m"
BLUE="${ESC}[0;34m"
NC="${ESC}[0m" # No Color

# Function to draw progress bar - simplified to avoid duplicates
draw_progress_bar() {
    local percentage=$1
    local bar_width=50
    local filled=$((percentage * bar_width / 100))
    local empty=$((bar_width - filled))
    
    # Create the bar using a simpler approach
    local bar=""
    local i=0
    
    # Fill the completed portion
    while [ $i -lt $filled ]; do
        bar="${bar}█"
        i=$((i + 1))
    done
    
    # Add the empty portion
    i=0
    while [ $i -lt $empty ]; do
        bar="${bar}░"
        i=$((i + 1))
    done
    
    # Clear the line and display the progress bar - single line only
    printf "\r${BLUE}[${GREEN}${bar}${BLUE}] ${GREEN}%3d%%${NC} Copying to ZRAM...     " "$percentage"
    
    # Log progress to physical drive if debug mode is on
    if [ "${DEBUG_MODE}" = "yes" ] && [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown') PROGRESS: ${percentage}%" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

# Function to build rsync exclude/include flags from configuration
build_rsync_filters() {
    local filters=""

    # Add user-specified include patterns first (they take precedence)
    if [ -n "$ZRAM_INCLUDE_PATTERNS" ]; then
        log_debug "Processing include patterns: $ZRAM_INCLUDE_PATTERNS"
        for pattern in $ZRAM_INCLUDE_PATTERNS; do
            filters="$filters --include=$pattern"
            log_debug "  Include: $pattern"
        done
    fi

    # Add mount-on-disk paths to exclude patterns (they'll be bind-mounted later)
    local exclude_patterns="$ZRAM_EXCLUDE_PATTERNS"
    if [ -n "$ZRAM_MOUNT_ON_DISK" ]; then
        log_debug "Adding mount-on-disk paths to exclusions: $ZRAM_MOUNT_ON_DISK"
        for mount_path in $ZRAM_MOUNT_ON_DISK; do
            # Remove leading/trailing slashes for consistency
            mount_path=$(echo "$mount_path" | sed 's:^/::; s:/$::')
            if [ -n "$mount_path" ]; then
                exclude_patterns="$exclude_patterns /$mount_path /$mount_path/*"
                log_debug "  Excluding (will bind-mount): /$mount_path"
            fi
        done
    fi

    # Add user-specified exclude patterns
    if [ -n "$exclude_patterns" ]; then
        log_debug "Processing exclude patterns: $exclude_patterns"
        for pattern in $exclude_patterns; do
            filters="$filters --exclude=$pattern"
            log_debug "  Exclude: $pattern"
        done
    fi

    echo "$filters"
}

# Function to detect optimal number of parallel operations
detect_optimal_threads() {
    local cpu_cores=$(nproc 2>/dev/null || echo "1")
    local available_ram_mb=$(($(grep MemAvailable /proc/meminfo | awk '{print $2}') / 1024))

    # Start with CPU core count
    local optimal_threads=$cpu_cores

    # Adjust based on available RAM (each rsync process uses ~50-100MB)
    local max_ram_threads=$((available_ram_mb / 75))  # Conservative estimate
    if [ "$max_ram_threads" -lt "$optimal_threads" ]; then
        optimal_threads=$max_ram_threads
    fi

    # Ensure we have at least 1 thread and no more than 16 (diminishing returns)
    if [ "$optimal_threads" -lt 1 ]; then
        optimal_threads=1
    elif [ "$optimal_threads" -gt 16 ]; then
        optimal_threads=16
    fi

    log_debug "Detected ${cpu_cores} CPU cores, ${available_ram_mb}MB RAM"
    log_debug "Using ${optimal_threads} parallel rsync operations"

    echo "$optimal_threads"
}

# Function to analyze directory structure and create work distribution
create_work_distribution() {
    local source="$1"
    local thread_count="$2"
    local work_dir="/tmp/parallel_rsync_work"
    
    log_debug "Creating work distribution for ${thread_count} threads"
    
    # Create temporary directory for work files
    mkdir -p "$work_dir"
    rm -f "${work_dir}/job_"*
    
    # Get top-level directories and their sizes
    log_debug "Analyzing directory structure..."
    
    # Create list of directories with sizes (in KB)
    local dir_list="${work_dir}/directories.list"
    
    # Get subdirectories of source, excluding special directories
    find "$source" -maxdepth 1 -type d ! -path "$source" \
        ! -name "dev" ! -name "proc" ! -name "sys" ! -name "tmp" \
        ! -name "run" ! -name "mnt" ! -name "media" ! -name "lost+found" \
        2>/dev/null | while read dir; do
        if [ -d "$dir" ]; then
            local size_kb=$(du -sk "$dir" 2>/dev/null | awk '{print $1}' || echo "0")
            local dir_name=$(basename "$dir")
            echo "${size_kb}:${dir_name}" >> "$dir_list"
        fi
    done
    
    # Sort directories by size (largest first) for better load balancing
    sort -rn -t: -k1 "$dir_list" > "${dir_list}.sorted"
    
    # Distribute directories across job files using round-robin with load balancing
    local job_index=0
    
    # Initialize job size trackers and job lists
    for i in $(seq 0 $((thread_count - 1))); do
        echo "0" > "${work_dir}/job_${i}.size"
        touch "${work_dir}/job_${i}.list"
    done
    
    # Distribute directories to jobs, always picking the job with least total size
    while read line; do
        if [ -n "$line" ]; then
            local size=$(echo "$line" | cut -d: -f1)
            local dir_name=$(echo "$line" | cut -d: -f2)
            
            # Find job with minimum current size
            local min_job=0
            local min_size=$(cat "${work_dir}/job_0.size")
            for i in $(seq 1 $((thread_count - 1))); do
                local current_size=$(cat "${work_dir}/job_${i}.size")
                if [ "$current_size" -lt "$min_size" ]; then
                    min_size=$current_size
                    min_job=$i
                fi
            done
            
            # Add directory to the job with minimum size
            echo "$dir_name" >> "${work_dir}/job_${min_job}.list"
            local new_size=$((min_size + size))
            echo "$new_size" > "${work_dir}/job_${min_job}.size"
            
            log_debug "Assigned ${dir_name} (${size}KB) to job ${min_job}"
        fi
    done < "${dir_list}.sorted"
    
    # Add any remaining files in root directory to job 0
    echo "ROOT_FILES" >> "${work_dir}/job_0.list"
    
    # Log job distribution
    for i in $(seq 0 $((thread_count - 1))); do
        local job_size_kb=$(cat "${work_dir}/job_${i}.size")
        local job_size_mb=$((job_size_kb / 1024))
        local dir_count=$(wc -l < "${work_dir}/job_${i}.list")
        log_debug "Job ${i}: ${dir_count} items, ~${job_size_mb}MB"
    done
    
    echo "$work_dir"
}

# Function for parallel rsync with progress monitoring
copy_with_parallel_progress() {
    local source="$1"
    local dest="$2"
    local update_interval=2
    
    log_debug "Starting parallel copy from ${source} to ${dest}"
    
    # Detect optimal thread count
    local thread_count=$(detect_optimal_threads)
    log_info "Using ${thread_count} parallel operations for maximum speed"
    
    # Get total size to copy (in KB)
    log_debug "Calculating total source size..."
    local total_kb=$(du -sk "$source" 2>/dev/null | awk '{print $1}')
    if [ -z "$total_kb" ] || [ "$total_kb" -eq 0 ]; then
        log_error "Could not determine source directory size"
        return 1
    fi
    
    log_debug "Total size to copy: ${total_kb} KB ($(($total_kb / 1024)) MB)"
    
    # Create work distribution
    local work_dir=$(create_work_distribution "$source" "$thread_count")

    # Common rsync options - default exclusions
    local RSYNC_EXCLUDE="--exclude=/dev/* --exclude=/proc/* --exclude=/sys/* --exclude=/tmp/* --exclude=/run/* --exclude=/mnt/* --exclude=/media/* --exclude=/lost+found --exclude=/var/log/journal/*"

    # Add user-configured filters (includes and excludes)
    local USER_FILTERS=$(build_rsync_filters)
    if [ -n "$USER_FILTERS" ]; then
        log_info "Applying user-configured include/exclude filters"
        RSYNC_EXCLUDE="$RSYNC_EXCLUDE $USER_FILTERS"
    fi

    # Display header
    echo ""
    echo ""
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "            Copying filesystem to ZRAM (${thread_count} parallel operations)"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    # Start the progress bar at 0%
    draw_parallel_progress_bar 0 "$thread_count"
    
    # Start all rsync jobs in parallel
    local start_time=$(date +%s)
    
    for i in $(seq 0 $((thread_count - 1))); do
        local job_file="${work_dir}/job_${i}.list"
        local job_log="${work_dir}/job_${i}.log"

        if [ -s "$job_file" ]; then
            # Start rsync job in background
            (
                # Process each directory/file in this job
                while read item; do
                    rsync_exit=1
                    retry_count=0
                    max_retries=3

                    while [ $rsync_exit -ne 0 ] && [ $retry_count -lt $max_retries ]; do
                        if [ "$item" = "ROOT_FILES" ]; then
                            # Copy root level files and symlinks (excluding directories that are handled separately)
                            # shellcheck disable=SC2086
                            rsync -ax \
                                  --include="/*" --exclude="/*/" \
                                  --exclude="/dev" --exclude="/proc" --exclude="/sys" --exclude="/tmp" \
                                  --exclude="/run" --exclude="/mnt" --exclude="/media" --exclude="/lost+found" \
                                  $USER_FILTERS \
                                  "${source}/" "${dest}/" 2>>"$job_log"
                            rsync_exit=$?
                        else
                            # Copy specific directory
                            mkdir -p "${dest}/${item}"
                            # shellcheck disable=SC2086
                            rsync -ax --delete \
                                  $RSYNC_EXCLUDE \
                                  "${source}/${item}/" "${dest}/${item}/" 2>>"$job_log"
                            rsync_exit=$?
                        fi

                        if [ $rsync_exit -ne 0 ]; then
                            retry_count=$((retry_count + 1))
                            if [ $retry_count -lt $max_retries ]; then
                                echo "Retry $retry_count/$max_retries for $item" >> "$job_log"
                                sleep 1
                            else
                                echo "FAILED after $max_retries retries: $item (exit code: $rsync_exit)" >> "$job_log"
                            fi
                        fi
                    done
                done < "$job_file"
            ) &

            local job_pid=$!
            echo "$job_pid" > "${work_dir}/job_${i}.pid"
            log_debug "Started rsync job ${i} with PID ${job_pid}"
        fi
    done
    
    # Monitor progress across all jobs
    local last_percentage=0
    local max_wait=1800  # 30 minute timeout
    local elapsed=0
    
    while [ $elapsed -lt $max_wait ]; do
        local running_jobs=0
        
        # Check if any jobs are still running
        for i in $(seq 0 $((thread_count - 1))); do
            local pid_file="${work_dir}/job_${i}.pid"
            if [ -f "$pid_file" ]; then
                local job_pid=$(cat "$pid_file")
                if [ -n "$job_pid" ] && kill -0 "$job_pid" 2>/dev/null; then
                    running_jobs=$((running_jobs + 1))
                fi
            fi
        done
        
        if [ $running_jobs -eq 0 ]; then
            break
        fi
        
        # Calculate progress based on destination size
        local current_kb=$(du -sk "$dest" 2>/dev/null | awk '{print $1}')
        
        if [ -n "$current_kb" ] && [ "$current_kb" -gt 0 ]; then
            local current_percentage=$(( (current_kb * 100) / total_kb ))
            
            # Cap at 99% until all jobs are done
            if [ "$current_percentage" -gt 99 ] && [ $running_jobs -gt 0 ]; then
                current_percentage=99
            fi
            
            # Update progress bar if percentage changed
            if [ "$current_percentage" -ne "$last_percentage" ]; then
                draw_parallel_progress_bar "$current_percentage" "$thread_count" "$running_jobs"
                last_percentage=$current_percentage
                log_debug "Progress: ${current_percentage}% (${current_kb}KB/${total_kb}KB, ${running_jobs} jobs active)"
            fi
        fi
        
        sleep $update_interval
        elapsed=$((elapsed + update_interval))
    done
    
    # Wait for all remaining jobs and collect exit codes
    local overall_exit=0
    for i in $(seq 0 $((thread_count - 1))); do
        local pid_file="${work_dir}/job_${i}.pid"
        if [ -f "$pid_file" ]; then
            local job_pid=$(cat "$pid_file")
            if [ -n "$job_pid" ]; then
                wait "$job_pid"
                local job_exit=$?
                if [ $job_exit -ne 0 ]; then
                    log_debug "Job ${i} exited with code ${job_exit}"
                    overall_exit=$job_exit
                fi
            fi
        fi
    done
    
    # Show 100% completion
    draw_parallel_progress_bar 100 "$thread_count" 0
    echo ""
    echo ""
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local speed_mb_s=$(awk "BEGIN {printf \"%.1f\", ($total_kb/1024)/$duration}")
    
    log_info "Parallel copy completed in ${duration} seconds (${speed_mb_s} MB/s)"
    
    # Cleanup work files
    rm -rf "$work_dir"
    
    return $overall_exit
}

# Enhanced progress bar for parallel operations
draw_parallel_progress_bar() {
    local percentage=$1
    local total_threads=$2
    local active_threads=${3:-$total_threads}
    local bar_width=50
    local filled=$((percentage * bar_width / 100))
    local empty=$((bar_width - filled))
    
    # Create the bar
    local bar=""
    local i=0
    
    # Fill the completed portion
    while [ $i -lt $filled ]; do
        bar="${bar}█"
        i=$((i + 1))
    done
    
    # Add the empty portion
    i=0
    while [ $i -lt $empty ]; do
        bar="${bar}░"
        i=$((i + 1))
    done
    
    # Clear line and display enhanced progress bar
    printf "\r${BLUE}[${GREEN}${bar}${BLUE}] ${GREEN}%3d%%${NC} ${YELLOW}[${active_threads}/${total_threads} threads]${NC} Copying...     " "$percentage"
    
    # Log progress to physical drive if debug mode is on
    if [ "${DEBUG_MODE}" = "yes" ] && [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown') PARALLEL-PROGRESS: ${percentage}% [${active_threads}/${total_threads} threads]" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

# Wrapper function that maintains compatibility but uses parallel implementation
copy_with_progress() {
    copy_with_parallel_progress "$@"
}

# Function to wait for a device to appear (supports encrypted devices)
# Usage: wait_for_device <device_spec> <timeout_seconds>
# Returns: 0 if device found, 1 if timeout
# Sets: RESOLVED_DEVICE to the resolved block device path
wait_for_device() {
    local device_spec="$1"
    local timeout="${2:-$WAIT_TIMEOUT}"
    local elapsed=0
    local interval=1

    RESOLVED_DEVICE=""

    log_info "Waiting for device ${device_spec} (timeout: ${timeout}s)..."

    while [ $elapsed -lt $timeout ]; do
        # Try to resolve the device
        local resolved=""

        # Handle UUID=, LABEL=, PARTUUID= formats
        if echo "${device_spec}" | grep -q "^UUID=\|^LABEL=\|^PARTUUID="; then
            if command -v blkid >/dev/null 2>&1; then
                resolved=$(blkid -l -t "${device_spec}" -o device 2>/dev/null)
            fi
        # Handle /dev/mapper/* paths (common for encrypted devices)
        elif echo "${device_spec}" | grep -q "^/dev/mapper/"; then
            if [ -b "${device_spec}" ]; then
                resolved="${device_spec}"
            fi
        # Handle /dev/disk/by-* paths
        elif echo "${device_spec}" | grep -q "^/dev/disk/"; then
            if [ -L "${device_spec}" ]; then
                resolved=$(readlink -f "${device_spec}" 2>/dev/null)
                if [ ! -b "$resolved" ]; then
                    resolved=""
                fi
            fi
        # Handle direct /dev/* paths
        elif [ "${device_spec#/dev/}" != "${device_spec}" ]; then
            if [ -b "${device_spec}" ]; then
                resolved="${device_spec}"
            fi
        fi

        # Check if we found a valid block device
        if [ -n "$resolved" ] && [ -b "$resolved" ]; then
            RESOLVED_DEVICE="$resolved"
            log_info "Device ${device_spec} found as ${RESOLVED_DEVICE} after ${elapsed}s"
            return 0
        fi

        # Wait and increment counter
        sleep $interval
        elapsed=$((elapsed + interval))

        # Log progress every 10 seconds
        if [ $((elapsed % 10)) -eq 0 ]; then
            log_debug "Still waiting for ${device_spec}... (${elapsed}s/${timeout}s)"
        fi
    done

    log_error "Timeout waiting for device ${device_spec} after ${timeout}s"
    return 1
}

# Function to setup ZRAM swap
setup_zram_swap() {
    log_debug "Setting up ZRAM swap device ${ZRAM_SWAP_DEVICE_NUM}"
    
    # Calculate ZRAM swap size if not specified
    local swap_size_mib="${ZRAM_SWAP_SIZE_MiB}"
    if [ "$swap_size_mib" -eq 0 ]; then
        # Auto-calculate: typically 25-50% of RAM, but consider available space
        local total_ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        local total_ram_mib=$((total_ram_kb / 1024))
        
        # Use 25% of total RAM for swap, but cap at 4GB
        swap_size_mib=$((total_ram_mib / 4))
        if [ "$swap_size_mib" -gt 4096 ]; then
            swap_size_mib=4096
        fi
        
        # Ensure minimum 512MB swap
        if [ "$swap_size_mib" -lt 512 ]; then
            swap_size_mib=512
        fi
        
        log_debug "Auto-calculated ZRAM swap size: ${swap_size_mib} MiB (based on ${total_ram_mib} MiB total RAM)"
    fi
    
    local zram_swap_device="/dev/zram${ZRAM_SWAP_DEVICE_NUM}"
    
    # Configure ZRAM swap device
    if [ ! -b "$zram_swap_device" ]; then
        # Try using zramctl if available
        if command -v zramctl >/dev/null; then
            log_debug "Using zramctl to create ZRAM swap device..."
            if ! zramctl --find --size "${swap_size_mib}M" --algorithm "${ZRAM_SWAP_ALGO}" >/dev/null 2>&1; then
                log_debug "zramctl failed for swap, trying manual approach..."
                # Manual configuration
                echo "${ZRAM_SWAP_ALGO}" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
                echo "${swap_size_mib}M" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/disksize 2>/dev/null
            fi
        else
            # Manual configuration
            log_debug "zramctl not available, using manual configuration for swap..."
            echo "${ZRAM_SWAP_ALGO}" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${swap_size_mib}M" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/disksize 2>/dev/null
        fi
    fi
    
    # Wait for device to be ready
    sleep 2
    
    # Verify device exists
    if [ ! -b "$zram_swap_device" ]; then
        log_error "ZRAM swap device $zram_swap_device does not exist after configuration!"
        return 1
    fi
    
    # Initialize swap on ZRAM device
    log_debug "Initializing swap on $zram_swap_device..."
    if mkswap "$zram_swap_device" >/dev/null 2>&1; then
        log_info "ZRAM swap device created successfully (${swap_size_mib} MiB)"
        
        # Add ZRAM swap entry to fstab in ZRAM root
        if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
            echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            echo "# ZRAM Swap (replaces original drive swap for safety)" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            echo "$zram_swap_device none swap sw,pri=${ZRAM_SWAP_PRIORITY} 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            log_debug "Added ZRAM swap entry to /etc/fstab with priority ${ZRAM_SWAP_PRIORITY}"
        fi
        
        return 0
    else
        log_error "Failed to initialize swap on $zram_swap_device!"
        return 1
    fi
}

# Load TRIGGER_PARAMETER and WAIT_TIMEOUT from config early (before the check)
# We need to source the config to get these values before proceeding
CONFIG_FILE="/conf/zramroot-config"
if [ -f "${CONFIG_FILE}" ]; then
    # Extract TRIGGER_PARAMETER value safely
    trigger_setting=$(grep "^TRIGGER_PARAMETER=" "${CONFIG_FILE}" 2>/dev/null | cut -d'"' -f2)
    if [ -n "${trigger_setting}" ]; then
        TRIGGER_PARAMETER="${trigger_setting}"
    fi
    # Extract WAIT_TIMEOUT value safely
    timeout_setting=$(grep "^WAIT_TIMEOUT=" "${CONFIG_FILE}" 2>/dev/null | cut -d'=' -f2)
    if [ -n "${timeout_setting}" ]; then
        WAIT_TIMEOUT="${timeout_setting}"
    fi
fi

# Check if trigger parameter is in cmdline before doing anything
log_kernel "Checking for ${TRIGGER_PARAMETER} parameter in kernel cmdline"
if ! echo " $(cat /proc/cmdline) " | grep -q "[[:space:]]${TRIGGER_PARAMETER}[[:space:]]"; then
    log_debug "No ${TRIGGER_PARAMETER} parameter found - exiting quietly"
    exit 0
fi

log_kernel "${TRIGGER_PARAMETER} parameter found - starting setup"

# --- Validate device number configuration ---
if [ "$ZRAM_DEVICE_NUM" -eq "$ZRAM_SWAP_DEVICE_NUM" ] && [ "$ZRAM_SWAP_ENABLED" = "yes" ]; then
    log_info "ZRAM_DEVICE_NUM ($ZRAM_DEVICE_NUM) equals ZRAM_SWAP_DEVICE_NUM ($ZRAM_SWAP_DEVICE_NUM)"
    log_info "Automatically adjusting ZRAM_SWAP_DEVICE_NUM to $((ZRAM_SWAP_DEVICE_NUM + 1))"
    ZRAM_SWAP_DEVICE_NUM=$((ZRAM_SWAP_DEVICE_NUM + 1))
fi

# Create necessary directories
mkdir -p /mnt
mkdir -p /tmp
mkdir -p "${ZRAM_TEMP_MNT}"

# Try to mount physical root for logging and file copying
# This is critical for encrypted devices - we need to wait for decryption to complete
REAL_ROOT_DEVICE="${ROOT}"
if [ -n "${REAL_ROOT_DEVICE}" ]; then
    log_debug "Attempting to mount physical root ${REAL_ROOT_DEVICE} for logging and copying"
    mkdir -p "${REAL_ROOT_MNT}"

    # Wait for the root device to appear (handles encrypted devices that need time to unlock)
    # Uses WAIT_TIMEOUT from config (default 120 seconds)
    if wait_for_device "${REAL_ROOT_DEVICE}" "${WAIT_TIMEOUT}"; then
        real_dev="${RESOLVED_DEVICE}"
        log_debug "Attempting to mount ${real_dev} at ${REAL_ROOT_MNT}"
        if mount -o rw "$real_dev" "${REAL_ROOT_MNT}" 2>/dev/null; then
            # Ensure log directory exists
            mkdir -p "${REAL_ROOT_LOG_DIR}"
            # Create/touch the log file to ensure it's writable
            touch "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
            log_debug "Physical root mounted successfully at ${REAL_ROOT_MNT}"
            log_debug "Log file created at ${REAL_ROOT_LOG_FILE}"
        else
            log_error "Failed to mount physical root device ${real_dev}"
        fi
    else
        log_error "Timeout waiting for physical root device: ${REAL_ROOT_DEVICE}"
        log_error "This may indicate the device doesn't exist or encryption unlock failed"
    fi
fi

# Load configuration - these defaults match zramroot.conf exactly
DEBUG_MODE="no"; DEBUG_LOG_DIR="/var/log"; DEBUG_LOG_DEVICE=""
ZRAM_SIZE_MiB=0; ZRAM_ALGO="lz4"; ZRAM_FS_TYPE="ext4"
ZRAM_MOUNT_OPTS="noatime"; RAM_MIN_FREE_MiB=512
ZRAM_BUFFER_PERCENT=10
ZRAM_DEVICE_NUM=0; TRIGGER_PARAMETER="zramroot"; WAIT_TIMEOUT=120
RAM_PREF_FREE_MiB=1024; ZRAM_MIN_FREE_MiB=256; ZRAM_MAX_FREE_MiB=35840
# ZRAM Swap defaults
ZRAM_SWAP_ENABLED="yes"; ZRAM_SWAP_DEVICE_NUM=1; ZRAM_SWAP_SIZE_MiB=0
ZRAM_SWAP_ALGO="lz4"; ZRAM_SWAP_PRIORITY=10
# Include/Exclude and Mount-on-Disk defaults
ZRAM_EXCLUDE_PATTERNS=""; ZRAM_INCLUDE_PATTERNS=""
ZRAM_MOUNT_ON_DISK=""; ZRAM_PHYSICAL_ROOT_OPTS="rw"

if [ -f "${CONFIG_FILE}" ]; then
    log_debug "Loading configuration from ${CONFIG_FILE}"
    . "${CONFIG_FILE}"
    log_debug "Configuration loaded - DEBUG_MODE=${DEBUG_MODE}"
fi

# Sanity-check debug log directory to avoid mounting over initramfs root
if [ -z "${DEBUG_LOG_DIR}" ] || [ "${DEBUG_LOG_DIR}" = "/" ]; then
    log_kernel "zramroot: DEBUG_LOG_DIR is empty or '/', forcing /var/log"
    DEBUG_LOG_DIR="/var/log"
fi

# Update log paths after loading config
if [ -n "${DEBUG_LOG_DEVICE}" ]; then
    mkdir -p "${DEBUG_LOG_DIR}" 2>/dev/null || true
    if ! mountpoint -q "${DEBUG_LOG_DIR}" 2>/dev/null; then
        mount -o rw "${DEBUG_LOG_DEVICE}" "${DEBUG_LOG_DIR}" 2>/dev/null || true
    fi
    REAL_ROOT_LOG_DIR="${DEBUG_LOG_DIR}"
else
    REAL_ROOT_LOG_DIR="${REAL_ROOT_MNT}${DEBUG_LOG_DIR}"
fi
REAL_ROOT_LOG_FILE="${REAL_ROOT_LOG_DIR}/zramroot-${DATE_TIME}.log"

# Set algorithm-specific compression estimates based on empirical testing
# These are not user-configurable as ZRAM doesn't allow tuning compression levels
case "${ZRAM_ALGO}" in
    "zstd")
        ESTIMATED_COMPRESSION_RATIO=3.0  # Conservative estimate for zstd
        ;;
    "lz4hc")
        ESTIMATED_COMPRESSION_RATIO=2.5  # Better compression than lz4
        ;;
    "lz4")
        ESTIMATED_COMPRESSION_RATIO=2.0  # Fast but moderate compression
        ;;
    "lzo"|"lzo-rle")
        ESTIMATED_COMPRESSION_RATIO=1.8  # Fastest, but least compression
        ;;
    *)
        ESTIMATED_COMPRESSION_RATIO=2.2  # Safe default for unknown algorithms
        ;;
esac

log_debug "Using compression ratio estimate of ${ESTIMATED_COMPRESSION_RATIO} for algorithm ${ZRAM_ALGO}"

ZRAM_DEVICE="/dev/zram${ZRAM_DEVICE_NUM}"

log_info "=== STARTING ZRAM ROOT SETUP PROCESS ==="

# Check available RAM
AVAILABLE_RAM_KB=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
if [ -z "$AVAILABLE_RAM_KB" ]; then
    AVAILABLE_RAM_KB=$(grep MemFree /proc/meminfo | awk '{print $2}')
fi

if ! echo "$AVAILABLE_RAM_KB" | grep -q '^[0-9]\+$'; then
    log_error "Cannot determine available RAM. Cannot proceed."
    exit 1
fi

AVAILABLE_RAM_MiB=$((AVAILABLE_RAM_KB / 1024))
log_debug "Available RAM: ${AVAILABLE_RAM_MiB} MiB"

# Calculate used size of physical root
if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
    ROOT_USED_KB=$(LC_ALL=POSIX df -k "${REAL_ROOT_MNT}" | awk 'NR==2 {print $3}')
    if ! echo "$ROOT_USED_KB" | grep -q '^[0-9]\+$'; then
        log_error "Could not determine used disk space on ${REAL_ROOT_MNT}."
        exit 1
    fi
    ROOT_USED_MiB=$((ROOT_USED_KB / 1024))
else
    # Fallback: estimate 4GB if we can't mount physical root
    ROOT_USED_MiB=4096
    log_debug "Could not mount physical root, estimating 4GB"
fi

log_info "Used size on physical root: ${ROOT_USED_MiB} MiB"

# Add buffer to root usage
BUFFER_MiB=$(awk -v u="$ROOT_USED_MiB" -v p="$ZRAM_BUFFER_PERCENT" 'BEGIN{printf "%.0f", u * p / 100}')
ROOT_WITH_BUFFER_MiB=$((ROOT_USED_MiB + BUFFER_MiB))

# Calculate expected compressed size using compression ratio
# This is the key fix: we need to account for compression when sizing ZRAM
EXPECTED_COMPRESSED_ROOT_MiB=$(awk -v r="$ROOT_WITH_BUFFER_MiB" -v c="$ESTIMATED_COMPRESSION_RATIO" 'BEGIN{printf "%.0f", r / c}')
log_info "Expected compressed size: ${EXPECTED_COMPRESSED_ROOT_MiB} MiB (ratio: ${ESTIMATED_COMPRESSION_RATIO})"

# Determine ZRAM size
if [ "$ZRAM_SIZE_MiB" -gt 0 ]; then
    FINAL_ZRAM_SIZE_MiB=$ZRAM_SIZE_MiB
    log_info "Using configured ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
else
    # Calculate dynamically based on compressed size
    if [ $((AVAILABLE_RAM_MiB - RAM_MIN_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
        log_error "Insufficient RAM: Available ${AVAILABLE_RAM_MiB} MiB < Needed $((RAM_MIN_FREE_MiB + EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB)) MiB."
        exit 1
    fi
    
    if [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB))
        log_info "RAM is tight: Using minimum ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    elif [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MAX_FREE_MiB)) -le 0 ]; then
        EXTRA_ZRAM=$((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB))
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + EXTRA_ZRAM))
        log_info "Medium RAM availability: Using ${FINAL_ZRAM_SIZE_MiB} MiB for ZRAM"
    else
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MAX_FREE_MiB))
        log_info "Plenty of RAM: Using maximum ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    fi
    
    # Additional safety check: ensure ZRAM size is reasonable
    # ZRAM size should be at least the compressed size or we risk running out of space
    MIN_SAFE_ZRAM=$((EXPECTED_COMPRESSED_ROOT_MiB + (EXPECTED_COMPRESSED_ROOT_MiB / 4)))  # Add 25% safety margin
    if [ "$FINAL_ZRAM_SIZE_MiB" -lt "$MIN_SAFE_ZRAM" ]; then
        log_info "Adjusting ZRAM size to safe minimum: ${MIN_SAFE_ZRAM} MiB (was ${FINAL_ZRAM_SIZE_MiB} MiB)"
        FINAL_ZRAM_SIZE_MiB=$MIN_SAFE_ZRAM
    fi
fi

# Load zram module if not already loaded
if ! lsmod | grep -q '^zram '; then
    log_debug "Loading zram kernel module..."
    modprobe zram || {
        log_error "Failed to load zram kernel module!"
        exit 1
    }
fi

# Wait for ZRAM control interface with polling
log_info "Waiting for ZRAM control interface..."
zram_wait=0
zram_max_wait=30
while [ $zram_wait -lt $zram_max_wait ]; do
    if [ -e /sys/class/zram-control ] || [ -e "/sys/block/zram${ZRAM_DEVICE_NUM}" ]; then
        log_debug "ZRAM control interface available after ${zram_wait}s"
        break
    fi
    sleep 1
    zram_wait=$((zram_wait + 1))
    if [ $((zram_wait % 5)) -eq 0 ]; then
        log_debug "Still waiting for ZRAM control interface... (${zram_wait}s/${zram_max_wait}s)"
    fi
done

if [ ! -e /sys/class/zram-control ] && [ ! -e "/sys/block/zram${ZRAM_DEVICE_NUM}" ]; then
    log_error "ZRAM control interface not available after ${zram_max_wait}s"
    log_error "Ensure kernel has CONFIG_ZRAM enabled and zram module is in initramfs"
    exit 1
fi

if command -v udevadm >/dev/null && [ -x "$(command -v udevadm)" ]; then
    udevadm settle || log_debug "udev settle failed or not available"
fi

# Check if ZRAM device exists, if not create/configure it
if [ ! -b "${ZRAM_DEVICE}" ]; then
    # Try using zramctl if available
    if command -v zramctl >/dev/null; then
        log_debug "Using zramctl to create ZRAM device..."
        if zramctl --find --size "${FINAL_ZRAM_SIZE_MiB}M" --algorithm "${ZRAM_ALGO}" >/dev/null 2>&1; then
            ZRAM_DEVICE=$(zramctl --output NAME --noheadings | head -1)
            log_debug "Created ZRAM device: ${ZRAM_DEVICE}"
        else
            log_debug "zramctl failed, trying manual approach..."
            # Fall back to manual configuration
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        fi
    else
        # No zramctl, try manual configuration
        log_debug "zramctl not available, using manual configuration..."
        echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
        echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
    fi
else
    # Device exists, check if it's configured
    if [ -f "/sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize" ]; then
        current_size=$(cat /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null || echo "0")
        if [ "$current_size" = "0" ]; then
            log_debug "ZRAM device exists but not configured, configuring now..."
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        else
            log_debug "ZRAM device already configured"
        fi
    fi
fi

# Wait for ZRAM device to be ready with polling
log_debug "Waiting for ZRAM device ${ZRAM_DEVICE} to be ready..."
zram_dev_wait=0
zram_dev_max_wait=30
while [ $zram_dev_wait -lt $zram_dev_max_wait ]; do
    if [ -b "${ZRAM_DEVICE}" ]; then
        log_debug "ZRAM device ${ZRAM_DEVICE} ready after ${zram_dev_wait}s"
        break
    fi
    sleep 1
    zram_dev_wait=$((zram_dev_wait + 1))
    if [ $((zram_dev_wait % 5)) -eq 0 ]; then
        log_debug "Still waiting for ${ZRAM_DEVICE}... (${zram_dev_wait}s/${zram_dev_max_wait}s)"
    fi
done

# Verify ZRAM device exists
if [ ! -b "${ZRAM_DEVICE}" ]; then
    log_error "ZRAM device ${ZRAM_DEVICE} does not exist after ${zram_dev_max_wait}s!"
    exit 1
fi

log_debug "ZRAM device configured successfully"

# Format ZRAM filesystem
log_info "Formatting ZRAM device with ${ZRAM_FS_TYPE} filesystem..."
mkfs_cmd="mkfs.${ZRAM_FS_TYPE}"
mkfs_opts=""

if ! command -v ${mkfs_cmd} >/dev/null; then
    case "${ZRAM_FS_TYPE}" in
        ext4)
            log_error "mkfs.ext4 not found in initramfs! Install e2fsprogs and run: sudo update-initramfs -u -k all"
            ;;
        btrfs)
            log_error "mkfs.btrfs not found in initramfs! Install btrfs-progs and run: sudo update-initramfs -u -k all"
            ;;
        xfs)
            log_error "mkfs.xfs not found in initramfs! Install xfsprogs and run: sudo update-initramfs -u -k all"
            ;;
        *)
            log_error "Filesystem utility ${mkfs_cmd} not found in initramfs!"
            ;;
    esac
    exit 1
fi

# Add specific options for filesystem types
if [ "$ZRAM_FS_TYPE" = "ext4" ]; then
    mkfs_opts="-F"
elif [ "$ZRAM_FS_TYPE" = "btrfs" ]; then
    mkfs_opts="-f"
elif [ "$ZRAM_FS_TYPE" = "xfs" ]; then
    mkfs_opts="-f"
fi

if ${mkfs_cmd} ${mkfs_opts} "${ZRAM_DEVICE}" >/dev/null 2>&1; then
    log_info "ZRAM device formatted successfully"
else
    log_error "Failed to format ZRAM device!"
    exit 1
fi

# Now mount ZRAM temporarily and copy files
mkdir -p "${ZRAM_TEMP_MNT}"
if mount -t "${ZRAM_FS_TYPE}" -o "rw,${ZRAM_MOUNT_OPTS}" "${ZRAM_DEVICE}" "${ZRAM_TEMP_MNT}"; then
    log_debug "ZRAM device mounted at ${ZRAM_TEMP_MNT}"
    
    # Copy filesystem from physical root to ZRAM ONLY if we successfully mounted physical root
    if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
        log_info "Copying root filesystem from ${REAL_ROOT_MNT} to ZRAM..."
        
        # Use the copy function with progress bar
        if copy_with_progress "${REAL_ROOT_MNT}" "${ZRAM_TEMP_MNT}"; then
            log_info "Filesystem copy completed successfully"
            
            # Create required directories in ZRAM root
            for dir in dev proc sys run tmp; do
                mkdir -p "${ZRAM_TEMP_MNT}/${dir}"
                chmod 755 "${ZRAM_TEMP_MNT}/${dir}"
            done
            
            # Modify /etc/fstab in ZRAM root
            if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
                log_debug "Backing up and modifying /etc/fstab in ZRAM root"
                cp "${ZRAM_TEMP_MNT}/etc/fstab" "${ZRAM_TEMP_MNT}/etc/fstab.zram_backup"
                
                # Create a temporary file for sed operations to avoid in-place editing issues
                temp_fstab="/tmp/fstab_temp.$$"
                
                # Comment out root filesystem entry
                sed 's|^\([^#].*[[:space:]]/[[:space:]].*\)$|# ZRAMROOT: \1|g' "${ZRAM_TEMP_MNT}/etc/fstab" > "$temp_fstab"
                
                # Comment out other mount points we want to disable in ZRAM
                sed 's|^\([^#].*[[:space:]]/boot[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab" > "$temp_fstab.2"
                sed 's|^\([^#].*[[:space:]]/boot/efi[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.2" > "$temp_fstab.3"
                sed 's|^\([^#].*[[:space:]]/home[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.3" > "$temp_fstab.4"
                sed 's|^\([^#].*[[:space:]]/var[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.4" > "$temp_fstab.5"
                
                # CRITICAL: Comment out swap partitions from original drive to prevent mounting
                # This ensures the original drive can be safely disconnected when using ZRAMroot
                sed 's|^\([^#].*[[:space:]]swap[[:space:]].*\)$|# ZRAMROOT-SWAP-DISABLED: \1|g' "$temp_fstab.5" > "$temp_fstab.6"
                
                log_debug "Disabled original drive swap partitions in ZRAM fstab"
                
                # Copy the final result back
                cp "$temp_fstab.6" "${ZRAM_TEMP_MNT}/etc/fstab"
                
                # Clean up temporary files
                rm -f "$temp_fstab" "$temp_fstab.2" "$temp_fstab.3" "$temp_fstab.4" "$temp_fstab.5" "$temp_fstab.6"
                
                log_debug "Successfully modified /etc/fstab"

                # Setup mount-on-disk bind mounts if configured
                if [ -n "$ZRAM_MOUNT_ON_DISK" ]; then
                    log_info "Configuring mount-on-disk directories..."

                    # Add the physical root mount itself to fstab so systemd knows about it
                    echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                    echo "# ZRAMROOT: Physical root mount (required for bind mounts)" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                    local phys_opts="${ZRAM_PHYSICAL_ROOT_OPTS:-rw}"
                    echo "${REAL_ROOT_DEVICE} /mnt/physical_root auto ${phys_opts},nofail 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                    log_debug "Added physical root mount entry to /etc/fstab: ${REAL_ROOT_DEVICE} -> /mnt/physical_root"

                    for mount_path in $ZRAM_MOUNT_ON_DISK; do
                        # Clean up path (remove leading/trailing slashes)
                        mount_path=$(echo "$mount_path" | sed 's:^/::; s:/$::')

                        if [ -z "$mount_path" ]; then
                            continue
                        fi

                        # Check if directory exists on physical root
                        if [ -d "${REAL_ROOT_MNT}/${mount_path}" ]; then
                            # Create empty directory in ZRAM root
                            mkdir -p "${ZRAM_TEMP_MNT}/${mount_path}"
                            log_debug "Created mount point /${mount_path} in ZRAM root"

                            # Add bind mount entry to fstab
                            echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                            echo "# ZRAMROOT: Bind mount from physical disk" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                            echo "/mnt/physical_root/${mount_path} /${mount_path} none bind 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                            log_info "Added bind mount for /${mount_path} from physical disk"
                        else
                            log_error "Warning: Mount-on-disk path /${mount_path} does not exist on physical root - skipping"
                        fi
                    done

                    # Mark that we need to keep physical root mounted
                    export ZRAMROOT_KEEP_PHYSICAL_MOUNTED="yes"
                fi

                # Setup ZRAM swap if enabled
                if [ "${ZRAM_SWAP_ENABLED}" = "yes" ]; then
                    log_info "Setting up ZRAM swap..."
                    setup_zram_swap
                fi
            fi
        else
            log_error "Failed to copy files from physical root to ZRAM!"
            exit 1
        fi
    else
        log_debug "Physical root not mounted, assuming ZRAM already has filesystem"
    fi
    
    # Sync and unmount
    sync
    sleep 1
    umount "${ZRAM_TEMP_MNT}" || {
        log_error "Failed to unmount ZRAM root!"
        exit 1
    }
    log_debug "ZRAM root unmounted successfully"
else
    log_error "Failed to mount ZRAM device for file copy!"
    exit 1
fi

# Calculate final mount options
final_mount_opts=$(echo "${ZRAM_MOUNT_OPTS},rw" | sed 's/,defaults//g; s/,ro//g; s/,rw,rw/,rw/g; s/^,\|,$//g')
[ -z "$final_mount_opts" ] && final_mount_opts="rw"

# Export ZRAM variables for use by the local script
log_info "Setting ZRAMROOT Variables..."
export ZRAMROOT_DEVICE="${ZRAM_DEVICE}"
export ZRAMROOT_FSTYPE="${ZRAM_FS_TYPE}"
export ZRAMROOT_ROOTFLAGS="${final_mount_opts}"

mkdir -p /conf
echo "ZRAMROOT_DEVICE=${ZRAM_DEVICE}" > /conf/zramroot_vars
echo "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}" >> /conf/zramroot_vars
echo "ZRAMROOT_ROOTFLAGS=${final_mount_opts}" >> /conf/zramroot_vars
chmod 644 /conf/zramroot_vars

# Also write to tmp as backup
echo "ZRAMROOT_DEVICE=${ZRAM_DEVICE}" > /tmp/zramroot_vars
echo "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}" >> /tmp/zramroot_vars
echo "ZRAMROOT_ROOTFLAGS=${final_mount_opts}" >> /tmp/zramroot_vars

log_info "ZRAMROOT_DEVICE=${ZRAM_DEVICE}"
log_info "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}"
log_info "ZRAMROOT_ROOTFLAGS=${final_mount_opts}"

# Final log entry
log_info "===== ZRAM ROOT PREPARATION SCRIPT FINISHED SUCCESSFULLY ====="

# --- LVM2 Cleanup Function ---
cleanup_lvm2() {
    # Check if LVM2 support is available
    if [ -f "/conf/lvm_support" ]; then
        . /conf/lvm_support
        if [ "${LVM_SUPPORT}" = "yes" ]; then
            log_info "Attempting to deactivate LVM2 volumes..."
            
            # Get the root device info to determine which VG to deactivate
            local root_dev="${REAL_ROOT_DEVICE}"
            local vg_name=""
            
            # Try to extract VG name from device path
            # Note: LVM uses single dash to separate VG-LV names, double dash for literal dashes
            if echo "${root_dev}" | grep -q "/dev/mapper/"; then
                # Try lvs first for accurate VG name (handles dashes correctly)
                local dm_name=$(basename "${root_dev}")
                if command -v lvs >/dev/null 2>&1; then
                    vg_name=$(lvs --noheadings -o vg_name "/dev/mapper/${dm_name}" 2>/dev/null | tr -d ' ')
                fi
                # Fallback to regex if lvs didn't work (common case: VG has no dashes)
                if [ -z "$vg_name" ]; then
                    vg_name=$(echo "${root_dev}" | sed 's|/dev/mapper/\([^-]*\)-.*|\1|')
                fi
            elif echo "${root_dev}" | grep -q "/dev/.*/"; then
                # Extract VG name from LVM path like /dev/vg0/root
                vg_name=$(echo "${root_dev}" | sed 's|/dev/\([^/]*\)/.*|\1|')
            fi
            
            if [ -n "${vg_name}" ]; then
                log_debug "Detected volume group: ${vg_name}"
                
                # First try to deactivate the specific logical volume
                if command -v lvchange >/dev/null 2>&1; then
                    log_debug "Deactivating logical volume: ${root_dev}"
                    lvchange -an "${root_dev}" 2>/dev/null || true
                fi
                
                # Then try to deactivate the entire volume group
                if command -v vgchange >/dev/null 2>&1; then
                    log_debug "Deactivating volume group: ${vg_name}"
                    vgchange -an "${vg_name}" 2>/dev/null || true
                fi
                
                # Give it a moment to complete
                sleep 2
                
                log_info "LVM2 volume group '${vg_name}' deactivated"
            else
                log_debug "Could not determine volume group name from ${root_dev}"
                
                # Fallback: try to deactivate all volume groups
                if command -v vgchange >/dev/null 2>&1; then
                    log_debug "Attempting to deactivate all volume groups"
                    vgchange -an 2>/dev/null || true
                    sleep 2
                    log_info "All LVM2 volumes deactivated"
                fi
            fi
        else
            log_debug "LVM2 support not available - skipping LVM2 cleanup"
        fi
    else
        log_debug "No LVM2 support configuration found - skipping LVM2 cleanup"
    fi
}

# Handle physical root mount based on mount-on-disk configuration
if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
    if [ "${ZRAMROOT_KEEP_PHYSICAL_MOUNTED}" = "yes" ]; then
        # Move physical root mount to /mnt/physical_root for bind mounts
        log_info "Keeping physical root mounted at /mnt/physical_root for bind mounts"

        # Create the new mount point in initramfs
        mkdir -p /mnt/physical_root

        # Determine mount options (default to read-only for safety)
        local phys_mount_opts="${ZRAM_PHYSICAL_ROOT_OPTS:-ro}"
        log_debug "Physical root will be mounted with options: ${phys_mount_opts}"

        # Remount at new location with specified options
        # First unmount from temp location
        sync
        umount "${REAL_ROOT_MNT}" 2>/dev/null || umount -l "${REAL_ROOT_MNT}" 2>/dev/null || true

        # Mount at final location
        mount -o "${phys_mount_opts}" "${REAL_ROOT_DEVICE}" /mnt/physical_root || {
            log_error "Failed to remount physical root at /mnt/physical_root"
            log_error "Bind mounts will not work!"
        }

        log_info "Physical root remounted successfully"

        # Export variable for init scripts to know physical root is mounted
        export ZRAMROOT_PHYSICAL_ROOT="/mnt/physical_root"
        echo "ZRAMROOT_PHYSICAL_ROOT=/mnt/physical_root" >> /conf/zramroot_vars
    else
        # No mount-on-disk configured, unmount physical root as normal
        log_debug "Unmounting physical root (no mount-on-disk configured)"
        sync
        umount "${REAL_ROOT_MNT}" || umount -l "${REAL_ROOT_MNT}" || true

        # After unmounting, try to deactivate LVM2 volumes
        cleanup_lvm2
    fi
fi

exit 0
