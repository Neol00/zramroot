#!/bin/busybox sh
# initramfs-zramroot-boot

# --- Global Variables ---
CONFIG_FILE="/conf/zramroot-config" 
DEBUG_MODE="no" # Will be loaded from config
REAL_ROOT_DEVICE="" # Will be set from ROOT environment variable
REAL_ROOT_MNT="/mnt/real_root_rw"  # For persistent logging and copying
DATE_TIME=$(date '+%Y%m%d-%H%M%S' 2>/dev/null || echo "unknown") # Generate log filename with date/time
REAL_ROOT_LOG_DIR="${REAL_ROOT_MNT}/var/log"
REAL_ROOT_LOG_FILE="${REAL_ROOT_LOG_DIR}/zramroot-${DATE_TIME}.log"
ZRAM_DEVICE="zram0"
TRIGGER_PARAMETER="zramroot" # Default trigger word
WAIT_TIMEOUT=5 # Seconds to wait for the real root device
ZRAM_DEVICE_NUM=0
ZRAM_SIZE_MiB=0
ZRAM_ALGO="lz4"
ZRAM_FS_TYPE="ext4"
ZRAM_MOUNT_OPTS="noatime"
RAM_MIN_FREE_MiB=512   # Minimum RAM to leave free after ZRAM allocation
ZRAM_MIN_FREE_MiB=256   # Minimum ZRAM to leave free for growth
RAM_PREF_FREE_MiB=512  # Preferred RAM to leave free
ZRAM_MAX_FREE_MiB=35840  # Maximum ZRAM to leave free for growth
ESTIMATED_COMPRESSION_RATIO=2.5
ZRAM_BUFFER_PERCENT=10
BOOT_ID=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")
ZRAM_TEMP_MNT="/tmp/zram_temp" # Use a temporary mount point in /tmp

# --- Enhanced Logging Functions ---
log_kernel() { 
    echo "zramroot: $@" > /dev/kmsg 2>/dev/null || true
}

log_debug() {
    if [ "${DEBUG_MODE}" = "yes" ]; then
        log_kernel "DEBUG: $@"
        # Also log to physical drive if mounted and writable
        if [ -w "${REAL_ROOT_LOG_FILE}" ]; then
            now=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
            echo "${now} ZRAMROOT-BOOT DEBUG: $@" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
        fi
    fi
}

log_error() {
    log_kernel "ERROR: $@"
    # Always log errors to physical drive if available
    if [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        now=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
        echo "${now} ZRAMROOT-BOOT ERROR: $@" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

log_info() {
    log_kernel "$@"
    # Log info messages to physical drive if debug mode is on
    if [ "${DEBUG_MODE}" = "yes" ] && [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        now=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
        echo "${now} ZRAMROOT-BOOT INFO: $@" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

# --- Progress Bar Functions ---
# Terminal control sequences
ESC='\033'
CLEAR_LINE="${ESC}[2K\r"
MOVE_UP="${ESC}[1A"
GREEN="${ESC}[0;32m"
YELLOW="${ESC}[1;33m"
BLUE="${ESC}[0;34m"
NC="${ESC}[0m" # No Color

# Function to draw progress bar - simplified to avoid duplicates
draw_progress_bar() {
    local percentage=$1
    local bar_width=50
    local filled=$((percentage * bar_width / 100))
    local empty=$((bar_width - filled))
    
    # Create the bar using a simpler approach
    local bar=""
    local i=0
    
    # Fill the completed portion
    while [ $i -lt $filled ]; do
        bar="${bar}█"
        i=$((i + 1))
    done
    
    # Add the empty portion
    i=0
    while [ $i -lt $empty ]; do
        bar="${bar}░"
        i=$((i + 1))
    done
    
    # Clear the line and display the progress bar - single line only
    printf "\r${BLUE}[${GREEN}${bar}${BLUE}] ${GREEN}%3d%%${NC} Copying to ZRAM...     " "$percentage"
    
    # Log progress to physical drive if debug mode is on
    if [ "${DEBUG_MODE}" = "yes" ] && [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown') PROGRESS: ${percentage}%" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

# Function to detect optimal number of parallel operations
detect_optimal_threads() {
    local cpu_cores=$(nproc 2>/dev/null || echo "1")
    local available_ram_mb=$(($(grep MemAvailable /proc/meminfo | awk '{print $2}') / 1024))
    
    # Start with CPU core count
    local optimal_threads=$cpu_cores
    
    # Adjust based on available RAM (each rsync process uses ~50-100MB)
    local max_ram_threads=$((available_ram_mb / 75))  # Conservative estimate
    if [ "$max_ram_threads" -lt "$optimal_threads" ]; then
        optimal_threads=$max_ram_threads
    fi
    
    # Ensure we have at least 1 thread and no more than 16 (diminishing returns)
    if [ "$optimal_threads" -lt 1 ]; then
        optimal_threads=1
    elif [ "$optimal_threads" -gt 16 ]; then
        optimal_threads=16
    fi
    
    log_debug "Detected ${cpu_cores} CPU cores, ${available_ram_mb}MB RAM"
    log_debug "Using ${optimal_threads} parallel rsync operations"
    
    echo "$optimal_threads"
}

# Function to analyze directory structure and create work distribution
create_work_distribution() {
    local source="$1"
    local thread_count="$2"
    local work_dir="/tmp/parallel_rsync_work"

    log_debug "Creating work distribution for ${thread_count} threads"

    # Create temporary directory for work files
    mkdir -p "$work_dir"
    rm -f "${work_dir}/job_"* "${work_dir}/"*.list* 2>/dev/null

    local dir_list="${work_dir}/directories.list"
    local work_items="${work_dir}/work_items.list"

    # Get top-level directories and their sizes
    log_debug "Analyzing directory structure..."

    # Scan top-level directories
    find "$source" -maxdepth 1 -type d ! -path "$source" \
        ! -name "dev" ! -name "proc" ! -name "sys" ! -name "tmp" \
        ! -name "run" ! -name "mnt" ! -name "media" ! -name "lost+found" \
        2>/dev/null | while read dir; do
        if [ -d "$dir" ]; then
            local size_kb=$(du -sk "$dir" 2>/dev/null | awk '{print $1}' || echo "0")
            local dir_name=$(basename "$dir")
            echo "${size_kb}:${dir_name}" >> "$dir_list"
        fi
    done

    # Calculate total size and threshold for splitting
    local total_kb=$(awk -F: '{sum+=$1} END{print sum}' "$dir_list")
    local avg_per_thread=$((total_kb / thread_count))
    local split_threshold=$((avg_per_thread * 2))  # Split dirs larger than 2x average

    log_debug "Total size: $((total_kb / 1024))MB, split threshold: $((split_threshold / 1024))MB"

    # Process each directory - split large ones, keep small ones whole
    while IFS=: read size_kb dir_name; do
        if [ "$size_kb" -gt "$split_threshold" ]; then
            # Large directory - split into subdirectories
            log_debug "Splitting large directory: ${dir_name} ($((size_kb / 1024))MB)"

            find "${source}/${dir_name}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read subdir; do
                local sub_size=$(du -sk "$subdir" 2>/dev/null | awk '{print $1}' || echo "0")
                local sub_name=$(echo "$subdir" | sed "s|^${source}/||")
                if [ "$sub_size" -gt 0 ]; then
                    echo "${sub_size}:SUBDIR:${sub_name}" >> "$work_items"
                fi
            done

            # Also add any files directly in this directory
            local files_size=$(find "${source}/${dir_name}" -maxdepth 1 -type f -o -maxdepth 1 -type l 2>/dev/null | \
                              xargs du -sk 2>/dev/null | awk '{sum+=$1} END{print sum}' || echo "0")
            if [ -n "$files_size" ] && [ "$files_size" -gt 0 ]; then
                echo "${files_size}:FILES:${dir_name}" >> "$work_items"
            fi
        else
            # Small directory - keep whole
            echo "${size_kb}:DIR:${dir_name}" >> "$work_items"
        fi
    done < "$dir_list"

    # Add root files as a work item
    echo "0:ROOT:." >> "$work_items"

    # Sort work items by size (largest first)
    sort -rn -t: -k1 "$work_items" > "${work_items}.sorted"

    # Initialize job files
    for i in $(seq 0 $((thread_count - 1))); do
        echo "0" > "${work_dir}/job_${i}.size"
        touch "${work_dir}/job_${i}.list"
    done

    # Distribute work items to jobs using load balancing
    while IFS=: read size_kb item_type item_path; do
        if [ -n "$item_path" ]; then
            # Find job with minimum current size
            local min_job=0
            local min_size=$(cat "${work_dir}/job_0.size")
            for i in $(seq 1 $((thread_count - 1))); do
                local current_size=$(cat "${work_dir}/job_${i}.size")
                if [ "$current_size" -lt "$min_size" ]; then
                    min_size=$current_size
                    min_job=$i
                fi
            done

            # Add work item to the job with minimum size
            echo "${item_type}:${item_path}" >> "${work_dir}/job_${min_job}.list"
            local new_size=$((min_size + size_kb))
            echo "$new_size" > "${work_dir}/job_${min_job}.size"

            log_debug "Assigned ${item_type} ${item_path} ($((size_kb / 1024))MB) to job ${min_job}"
        fi
    done < "${work_items}.sorted"

    # Log final job distribution
    for i in $(seq 0 $((thread_count - 1))); do
        local job_size_kb=$(cat "${work_dir}/job_${i}.size")
        local job_size_mb=$((job_size_kb / 1024))
        local item_count=$(wc -l < "${work_dir}/job_${i}.list")
        log_debug "Job ${i}: ${item_count} items, ~${job_size_mb}MB"
    done

    echo "$work_dir"
}

# Function for parallel rsync with progress monitoring
copy_with_parallel_progress() {
    local source="$1"
    local dest="$2"
    local update_interval=2
    
    log_debug "Starting parallel copy from ${source} to ${dest}"
    
    # Detect optimal thread count
    local thread_count=$(detect_optimal_threads)
    log_info "Using ${thread_count} parallel operations for maximum speed"
    
    # Get total size to copy (in KB)
    log_debug "Calculating total source size..."
    local total_kb=$(du -sk "$source" 2>/dev/null | awk '{print $1}')
    if [ -z "$total_kb" ] || [ "$total_kb" -eq 0 ]; then
        log_error "Could not determine source directory size"
        return 1
    fi
    
    log_debug "Total size to copy: ${total_kb} KB ($(($total_kb / 1024)) MB)"
    
    # Create work distribution
    local work_dir=$(create_work_distribution "$source" "$thread_count")
    
    # Common rsync options
    local RSYNC_EXCLUDE="--exclude=/dev/* --exclude=/proc/* --exclude=/sys/* --exclude=/tmp/* --exclude=/run/* --exclude=/mnt/* --exclude=/media/* --exclude=/lost+found --exclude=/var/log/journal/*"
    
    # Display header
    echo ""
    echo ""
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "            Copying filesystem to ZRAM (${thread_count} parallel operations)"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    # Start the progress bar at 0%
    draw_parallel_progress_bar 0 "$thread_count"
    
    # Start all rsync jobs in parallel
    local start_time=$(date +%s)
    
    for i in $(seq 0 $((thread_count - 1))); do
        local job_file="${work_dir}/job_${i}.list"
        local job_log="${work_dir}/job_${i}.log"
        
        if [ -s "$job_file" ]; then
            # Start rsync job in background
            (
                # Process each work item in this job
                while IFS=: read item_type item_path; do
                    case "$item_type" in
                        ROOT)
                            # Copy root level files and symlinks only
                            rsync -ax \
                                  --include="/*" --exclude="/*/" \
                                  --exclude="/dev" --exclude="/proc" --exclude="/sys" --exclude="/tmp" \
                                  --exclude="/run" --exclude="/mnt" --exclude="/media" --exclude="/lost+found" \
                                  "${source}/" "${dest}/" 2>>"$job_log"
                            ;;
                        DIR)
                            # Copy entire directory
                            mkdir -p "${dest}/${item_path}"
                            rsync -ax --delete \
                                  "${source}/${item_path}/" "${dest}/${item_path}/" 2>>"$job_log"
                            ;;
                        SUBDIR)
                            # Copy subdirectory (path already includes parent)
                            mkdir -p "${dest}/${item_path}"
                            rsync -ax --delete \
                                  "${source}/${item_path}/" "${dest}/${item_path}/" 2>>"$job_log"
                            ;;
                        FILES)
                            # Copy only files from this directory (not subdirs)
                            mkdir -p "${dest}/${item_path}"
                            rsync -ax \
                                  --include="/*" --exclude="/*/" \
                                  "${source}/${item_path}/" "${dest}/${item_path}/" 2>>"$job_log"
                            ;;
                    esac
                done < "$job_file"
            ) &
            
            local job_pid=$!
            echo "$job_pid" > "${work_dir}/job_${i}.pid"
            log_debug "Started rsync job ${i} with PID ${job_pid}"
        fi
    done
    
    # Monitor progress across all jobs
    local last_percentage=0
    local max_wait=1800  # 30 minute timeout
    local elapsed=0
    
    while [ $elapsed -lt $max_wait ]; do
        local running_jobs=0
        
        # Check if any jobs are still running
        for i in $(seq 0 $((thread_count - 1))); do
            local pid_file="${work_dir}/job_${i}.pid"
            if [ -f "$pid_file" ]; then
                local job_pid=$(cat "$pid_file")
                if [ -n "$job_pid" ] && kill -0 "$job_pid" 2>/dev/null; then
                    running_jobs=$((running_jobs + 1))
                fi
            fi
        done
        
        if [ $running_jobs -eq 0 ]; then
            break
        fi
        
        # Calculate progress based on destination size
        local current_kb=$(du -sk "$dest" 2>/dev/null | awk '{print $1}')
        
        if [ -n "$current_kb" ] && [ "$current_kb" -gt 0 ]; then
            local current_percentage=$(( (current_kb * 100) / total_kb ))
            
            # Cap at 99% until all jobs are done
            if [ "$current_percentage" -gt 99 ] && [ $running_jobs -gt 0 ]; then
                current_percentage=99
            fi
            
            # Update progress bar if percentage changed
            if [ "$current_percentage" -ne "$last_percentage" ]; then
                draw_parallel_progress_bar "$current_percentage" "$thread_count" "$running_jobs"
                last_percentage=$current_percentage
                log_debug "Progress: ${current_percentage}% (${current_kb}KB/${total_kb}KB, ${running_jobs} jobs active)"
            fi
        fi
        
        sleep $update_interval
        elapsed=$((elapsed + update_interval))
    done
    
    # Wait for all remaining jobs and collect exit codes
    local overall_exit=0
    for i in $(seq 0 $((thread_count - 1))); do
        local pid_file="${work_dir}/job_${i}.pid"
        if [ -f "$pid_file" ]; then
            local job_pid=$(cat "$pid_file")
            if [ -n "$job_pid" ]; then
                wait "$job_pid"
                local job_exit=$?
                if [ $job_exit -ne 0 ]; then
                    log_debug "Job ${i} exited with code ${job_exit}"
                    overall_exit=$job_exit
                fi
            fi
        fi
    done
    
    # Show 100% completion
    draw_parallel_progress_bar 100 "$thread_count" 0
    echo ""
    echo ""
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local speed_mb_s=$(awk "BEGIN {printf \"%.1f\", ($total_kb/1024)/$duration}")
    
    log_info "Parallel copy completed in ${duration} seconds (${speed_mb_s} MB/s)"
    
    # Cleanup work files
    rm -rf "$work_dir"
    
    return $overall_exit
}

# Enhanced progress bar for parallel operations
draw_parallel_progress_bar() {
    local percentage=$1
    local total_threads=$2
    local active_threads=${3:-$total_threads}
    local bar_width=50
    local filled=$((percentage * bar_width / 100))
    local empty=$((bar_width - filled))
    
    # Create the bar
    local bar=""
    local i=0
    
    # Fill the completed portion
    while [ $i -lt $filled ]; do
        bar="${bar}█"
        i=$((i + 1))
    done
    
    # Add the empty portion
    i=0
    while [ $i -lt $empty ]; do
        bar="${bar}░"
        i=$((i + 1))
    done
    
    # Clear line and display enhanced progress bar
    printf "\r${BLUE}[${GREEN}${bar}${BLUE}] ${GREEN}%3d%%${NC} ${YELLOW}[${active_threads}/${total_threads} threads]${NC} Copying...     " "$percentage"
    
    # Log progress to physical drive if debug mode is on
    if [ "${DEBUG_MODE}" = "yes" ] && [ -w "${REAL_ROOT_LOG_FILE}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown') PARALLEL-PROGRESS: ${percentage}% [${active_threads}/${total_threads} threads]" >> "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
    fi
}

# Wrapper function that maintains compatibility but uses parallel implementation
copy_with_progress() {
    copy_with_parallel_progress "$@"
}

# Function to setup ZRAM swap
setup_zram_swap() {
    log_debug "Setting up ZRAM swap device ${ZRAM_SWAP_DEVICE_NUM}"
    
    # Calculate ZRAM swap size if not specified
    local swap_size_mib="${ZRAM_SWAP_SIZE_MiB}"
    if [ "$swap_size_mib" -eq 0 ]; then
        # Auto-calculate: typically 25-50% of RAM, but consider available space
        local total_ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        local total_ram_mib=$((total_ram_kb / 1024))
        
        # Use 25% of total RAM for swap, but cap at 4GB
        swap_size_mib=$((total_ram_mib / 4))
        if [ "$swap_size_mib" -gt 4096 ]; then
            swap_size_mib=4096
        fi
        
        # Ensure minimum 512MB swap
        if [ "$swap_size_mib" -lt 512 ]; then
            swap_size_mib=512
        fi
        
        log_debug "Auto-calculated ZRAM swap size: ${swap_size_mib} MiB (based on ${total_ram_mib} MiB total RAM)"
    fi
    
    local zram_swap_device="/dev/zram${ZRAM_SWAP_DEVICE_NUM}"
    
    # Configure ZRAM swap device
    if [ ! -b "$zram_swap_device" ]; then
        # Try using zramctl if available
        if command -v zramctl >/dev/null; then
            log_debug "Using zramctl to create ZRAM swap device..."
            if ! zramctl --find --size "${swap_size_mib}M" --algorithm "${ZRAM_SWAP_ALGO}" >/dev/null 2>&1; then
                log_debug "zramctl failed for swap, trying manual approach..."
                # Manual configuration
                echo "${ZRAM_SWAP_ALGO}" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
                echo "${swap_size_mib}M" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/disksize 2>/dev/null
            fi
        else
            # Manual configuration
            log_debug "zramctl not available, using manual configuration for swap..."
            echo "${ZRAM_SWAP_ALGO}" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${swap_size_mib}M" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/disksize 2>/dev/null
        fi
    fi
    
    # Wait for device to be ready
    sleep 2
    
    # Verify device exists
    if [ ! -b "$zram_swap_device" ]; then
        log_error "ZRAM swap device $zram_swap_device does not exist after configuration!"
        return 1
    fi
    
    # Initialize swap on ZRAM device
    log_debug "Initializing swap on $zram_swap_device..."
    if mkswap "$zram_swap_device" >/dev/null 2>&1; then
        log_info "ZRAM swap device created successfully (${swap_size_mib} MiB)"
        
        # Add ZRAM swap entry to fstab in ZRAM root
        if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
            echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            echo "# ZRAM Swap (replaces original drive swap for safety)" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            echo "$zram_swap_device none swap sw,pri=${ZRAM_SWAP_PRIORITY} 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            log_debug "Added ZRAM swap entry to /etc/fstab with priority ${ZRAM_SWAP_PRIORITY}"
        fi
        
        return 0
    else
        log_error "Failed to initialize swap on $zram_swap_device!"
        return 1
    fi
}

# Load configuration EARLY (before checking kernel parameter or showing prompt)
ZRAM_INTERACTIVE_PROMPT="no"
ZRAM_DEFAULT_CHOICE="no"
ZRAM_PROMPT_TIMEOUT=10

if [ -f "${CONFIG_FILE}" ]; then
    log_debug "Loading configuration from ${CONFIG_FILE}"
    . "${CONFIG_FILE}"
    log_debug "Early configuration loaded"
fi

# --- Interactive Prompt Function ---
prompt_user_for_zram() {
    local timeout="${ZRAM_PROMPT_TIMEOUT}"
    local default="${ZRAM_DEFAULT_CHOICE}"

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "                      ZRAM Root Boot Configuration"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    if [ "$default" = "yes" ]; then
        echo "  Boot with ZRAM (copy root filesystem to RAM)? [Y/n]"
        echo "  Default: YES"
    else
        echo "  Boot with ZRAM (copy root filesystem to RAM)? [y/N]"
        echo "  Default: NO"
    fi

    if [ "$timeout" -gt 0 ]; then
        echo "  Timeout: ${timeout} seconds"
    fi

    echo ""
    echo -n "  Choice: "

    # Read user input with timeout
    local choice=""
    if [ "$timeout" -eq 0 ]; then
        # No timeout - wait indefinitely
        read choice
    else
        # Use timeout
        choice=$(timeout "$timeout" sh -c 'read choice; echo "$choice"' 2>/dev/null || echo "")
    fi

    # Process choice
    choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]')

    if [ -z "$choice" ]; then
        # No input - use default
        echo ""
        echo "  Using default: $default"
        echo ""
        if [ "$default" = "yes" ]; then
            return 0
        else
            return 1
        fi
    elif [ "$choice" = "y" ] || [ "$choice" = "yes" ]; then
        echo ""
        echo "  Booting with ZRAM..."
        echo ""
        return 0
    elif [ "$choice" = "n" ] || [ "$choice" = "no" ]; then
        echo ""
        echo "  Skipping ZRAM, booting normally..."
        echo ""
        return 1
    else
        # Invalid input - use default
        echo ""
        echo "  Invalid input. Using default: $default"
        echo ""
        if [ "$default" = "yes" ]; then
            return 0
        else
            return 1
        fi
    fi
}

# --- Determine if we should boot with ZRAM ---
USE_ZRAM=0

if [ "${ZRAM_INTERACTIVE_PROMPT}" = "yes" ]; then
    # Interactive mode - always prompt user
    log_kernel "Interactive prompt mode enabled - asking user"
    if prompt_user_for_zram; then
        USE_ZRAM=1
        log_kernel "User chose to boot with ZRAM"
    else
        log_kernel "User chose normal boot - exiting"
        exit 0
    fi
else
    # Kernel parameter mode - check for zramroot parameter
    log_kernel "Checking for zramroot parameter in kernel cmdline"
    if echo " $(cat /proc/cmdline) " | grep -q "[[:space:]]zramroot[[:space:]]"; then
        USE_ZRAM=1
        log_kernel "zramroot parameter found - starting setup"
    else
        log_debug "No zramroot parameter found - exiting quietly"
        exit 0
    fi
fi

# If we get here, USE_ZRAM=1, so proceed with ZRAM setup
log_kernel "Starting ZRAM root setup"

# Create necessary directories
mkdir -p /mnt
mkdir -p /tmp
mkdir -p "${ZRAM_TEMP_MNT}"

# Try to mount physical root for logging and file copying
REAL_ROOT_DEVICE="${ROOT}"
if [ -n "${REAL_ROOT_DEVICE}" ]; then
    log_debug "Attempting to mount physical root ${REAL_ROOT_DEVICE} for logging and copying"
    mkdir -p "${REAL_ROOT_MNT}"
    
    # Wait a bit for device to be ready
    sleep 2
    
    # Try to find the real device
    real_dev=""
    
    # First try resolving UUID/LABEL style devices
    if echo "${REAL_ROOT_DEVICE}" | grep -q "^UUID=\|^LABEL="; then
        if command -v blkid >/dev/null 2>&1; then
            real_dev=$(blkid -l -t "${REAL_ROOT_DEVICE}" -o device 2>/dev/null)
            log_debug "Resolved ${REAL_ROOT_DEVICE} to ${real_dev}"
        fi
    # Handle direct device paths
    elif [ "${REAL_ROOT_DEVICE#/dev/}" != "${REAL_ROOT_DEVICE}" ] && [ -b "${REAL_ROOT_DEVICE}" ]; then
        real_dev="${REAL_ROOT_DEVICE}"
        log_debug "Using direct device path: ${real_dev}"
    fi
    
    if [ -n "$real_dev" ] && [ -b "$real_dev" ]; then
        log_debug "Attempting to mount ${real_dev} at ${REAL_ROOT_MNT}"
        if mount -o rw "$real_dev" "${REAL_ROOT_MNT}" 2>/dev/null; then
            # Ensure log directory exists
            mkdir -p "${REAL_ROOT_LOG_DIR}"
            # Create/touch the log file to ensure it's writable
            touch "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
            log_debug "Physical root mounted successfully at ${REAL_ROOT_MNT}"
            log_debug "Log file created at ${REAL_ROOT_LOG_FILE}"
        else
            log_error "Failed to mount physical root device ${real_dev}"
        fi
    else
        log_error "Could not find physical root device: ${REAL_ROOT_DEVICE}"
    fi
fi

# Set remaining default values (main config already loaded earlier)
DEBUG_MODE="${DEBUG_MODE:-no}"
ZRAM_SIZE_MiB="${ZRAM_SIZE_MiB:-0}"
ZRAM_ALGO="${ZRAM_ALGO:-zstd}"
ZRAM_FS_TYPE="${ZRAM_FS_TYPE:-ext4}"
ZRAM_MOUNT_OPTS="${ZRAM_MOUNT_OPTS:-defaults,noatime}"
RAM_MIN_FREE_MiB="${RAM_MIN_FREE_MiB:-512}"
ZRAM_BUFFER_PERCENT="${ZRAM_BUFFER_PERCENT:-10}"
ZRAM_DEVICE_NUM="${ZRAM_DEVICE_NUM:-0}"
TRIGGER_PARAMETER="${TRIGGER_PARAMETER:-zramroot}"
WAIT_TIMEOUT="${WAIT_TIMEOUT:-5}"
RAM_PREF_FREE_MiB="${RAM_PREF_FREE_MiB:-1024}"
ZRAM_MIN_FREE_MiB="${ZRAM_MIN_FREE_MiB:-256}"
ZRAM_MAX_FREE_MiB="${ZRAM_MAX_FREE_MiB:-35840}"
# ZRAM Swap defaults
ZRAM_SWAP_ENABLED="${ZRAM_SWAP_ENABLED:-yes}"
ZRAM_SWAP_DEVICE_NUM="${ZRAM_SWAP_DEVICE_NUM:-1}"
ZRAM_SWAP_SIZE_MiB="${ZRAM_SWAP_SIZE_MiB:-0}"
ZRAM_SWAP_ALGO="${ZRAM_SWAP_ALGO:-lz4}"
ZRAM_SWAP_PRIORITY="${ZRAM_SWAP_PRIORITY:-10}"

log_debug "Configuration loaded - DEBUG_MODE=${DEBUG_MODE}"

# Set algorithm-specific compression estimates based on empirical testing
# These are not user-configurable as ZRAM doesn't allow tuning compression levels
case "${ZRAM_ALGO}" in
    "zstd")
        ESTIMATED_COMPRESSION_RATIO=3.0  # Conservative estimate for zstd
        ;;
    "lz4hc")
        ESTIMATED_COMPRESSION_RATIO=2.5  # Better compression than lz4
        ;;
    "lz4")
        ESTIMATED_COMPRESSION_RATIO=2.0  # Fast but moderate compression
        ;;
    "lzo"|"lzo-rle")
        ESTIMATED_COMPRESSION_RATIO=1.8  # Fastest, but least compression
        ;;
    *)
        ESTIMATED_COMPRESSION_RATIO=2.2  # Safe default for unknown algorithms
        ;;
esac

log_debug "Using compression ratio estimate of ${ESTIMATED_COMPRESSION_RATIO} for algorithm ${ZRAM_ALGO}"

ZRAM_DEVICE="/dev/zram${ZRAM_DEVICE_NUM}"

log_info "=== STARTING ZRAM ROOT SETUP PROCESS ==="

# Check available RAM
AVAILABLE_RAM_KB=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
if [ -z "$AVAILABLE_RAM_KB" ]; then
    AVAILABLE_RAM_KB=$(grep MemFree /proc/meminfo | awk '{print $2}')
fi

if ! echo "$AVAILABLE_RAM_KB" | grep -q '^[0-9]\+$'; then
    log_error "Cannot determine available RAM. Cannot proceed."
    exit 1
fi

AVAILABLE_RAM_MiB=$((AVAILABLE_RAM_KB / 1024))
log_debug "Available RAM: ${AVAILABLE_RAM_MiB} MiB"

# Calculate used size of physical root
if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
    ROOT_USED_KB=$(LC_ALL=POSIX df -k "${REAL_ROOT_MNT}" | awk 'NR==2 {print $3}')
    if ! echo "$ROOT_USED_KB" | grep -q '^[0-9]\+$'; then
        log_error "Could not determine used disk space on ${REAL_ROOT_MNT}."
        exit 1
    fi
    ROOT_USED_MiB=$((ROOT_USED_KB / 1024))
else
    # Fallback: estimate 4GB if we can't mount physical root
    ROOT_USED_MiB=4096
    log_debug "Could not mount physical root, estimating 4GB"
fi

log_info "Used size on physical root: ${ROOT_USED_MiB} MiB"

# Add buffer to root usage
BUFFER_MiB=$(awk -v u="$ROOT_USED_MiB" -v p="$ZRAM_BUFFER_PERCENT" 'BEGIN{printf "%.0f", u * p / 100}')
ROOT_WITH_BUFFER_MiB=$((ROOT_USED_MiB + BUFFER_MiB))

# Calculate expected compressed size using compression ratio
# This is the key fix: we need to account for compression when sizing ZRAM
EXPECTED_COMPRESSED_ROOT_MiB=$(awk -v r="$ROOT_WITH_BUFFER_MiB" -v c="$ESTIMATED_COMPRESSION_RATIO" 'BEGIN{printf "%.0f", r / c}')
log_info "Expected compressed size: ${EXPECTED_COMPRESSED_ROOT_MiB} MiB (ratio: ${ESTIMATED_COMPRESSION_RATIO})"

# Determine ZRAM size
if [ "$ZRAM_SIZE_MiB" -gt 0 ]; then
    FINAL_ZRAM_SIZE_MiB=$ZRAM_SIZE_MiB
    log_info "Using configured ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
else
    # Calculate dynamically based on compressed size
    if [ $((AVAILABLE_RAM_MiB - RAM_MIN_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
        log_error "Insufficient RAM: Available ${AVAILABLE_RAM_MiB} MiB < Needed $((RAM_MIN_FREE_MiB + EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB)) MiB."
        exit 1
    fi
    
    if [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB))
        log_info "RAM is tight: Using minimum ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    elif [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MAX_FREE_MiB)) -le 0 ]; then
        EXTRA_ZRAM=$((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB))
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + EXTRA_ZRAM))
        log_info "Medium RAM availability: Using ${FINAL_ZRAM_SIZE_MiB} MiB for ZRAM"
    else
        FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MAX_FREE_MiB))
        log_info "Plenty of RAM: Using maximum ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    fi
    
    # Additional safety check: ensure ZRAM size is reasonable
    # ZRAM size should be at least the compressed size or we risk running out of space
    MIN_SAFE_ZRAM=$((EXPECTED_COMPRESSED_ROOT_MiB + (EXPECTED_COMPRESSED_ROOT_MiB / 4)))  # Add 25% safety margin
    if [ "$FINAL_ZRAM_SIZE_MiB" -lt "$MIN_SAFE_ZRAM" ]; then
        log_info "Adjusting ZRAM size to safe minimum: ${MIN_SAFE_ZRAM} MiB (was ${FINAL_ZRAM_SIZE_MiB} MiB)"
        FINAL_ZRAM_SIZE_MiB=$MIN_SAFE_ZRAM
    fi
fi

# Load zram module if not already loaded
if ! lsmod | grep -q '^zram '; then
    log_debug "Loading zram kernel module..."
    modprobe zram || {
        log_error "Failed to load zram kernel module!"
        exit 1
    }
fi

# Wait for ZRAM device node to appear
sleep 3
if command -v udevadm >/dev/null && [ -x "$(command -v udevadm)" ]; then
    udevadm settle || log_debug "udev settle failed or not available"
fi

# Check if ZRAM device exists, if not create/configure it
if [ ! -b "${ZRAM_DEVICE}" ]; then
    # Try using zramctl if available
    if command -v zramctl >/dev/null; then
        log_debug "Using zramctl to create ZRAM device..."
        if zramctl --find --size "${FINAL_ZRAM_SIZE_MiB}M" --algorithm "${ZRAM_ALGO}" >/dev/null 2>&1; then
            ZRAM_DEVICE=$(zramctl --output NAME --noheadings | head -1)
            log_debug "Created ZRAM device: ${ZRAM_DEVICE}"
        else
            log_debug "zramctl failed, trying manual approach..."
            # Fall back to manual configuration
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        fi
    else
        # No zramctl, try manual configuration
        log_debug "zramctl not available, using manual configuration..."
        echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
        echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
    fi
else
    # Device exists, check if it's configured
    if [ -f "/sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize" ]; then
        current_size=$(cat /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null || echo "0")
        if [ "$current_size" = "0" ]; then
            log_debug "ZRAM device exists but not configured, configuring now..."
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        else
            log_debug "ZRAM device already configured"
        fi
    fi
fi

# Wait a bit more for device to be ready
sleep 2

# Verify ZRAM device exists
if [ ! -b "${ZRAM_DEVICE}" ]; then
    log_error "ZRAM device does not exist after configuration!"
    exit 1
fi

log_debug "ZRAM device configured successfully"

# Format ZRAM filesystem
log_info "Formatting ZRAM device with ${ZRAM_FS_TYPE} filesystem..."
mkfs_cmd="mkfs.${ZRAM_FS_TYPE}"
mkfs_opts=""

if ! command -v ${mkfs_cmd} >/dev/null; then
    log_error "Filesystem utility ${mkfs_cmd} not found in initramfs!"
    exit 1
fi

# Add specific options for filesystem types
if [ "$ZRAM_FS_TYPE" = "ext4" ]; then 
    mkfs_opts="-F"
elif [ "$ZRAM_FS_TYPE" = "btrfs" ]; then
    mkfs_opts="-f"
fi

if ${mkfs_cmd} ${mkfs_opts} "${ZRAM_DEVICE}" >/dev/null 2>&1; then
    log_info "ZRAM device formatted successfully"
else
    log_error "Failed to format ZRAM device!"
    exit 1
fi

# Now mount ZRAM temporarily and copy files
mkdir -p "${ZRAM_TEMP_MNT}"
if mount -t "${ZRAM_FS_TYPE}" -o "rw,${ZRAM_MOUNT_OPTS}" "${ZRAM_DEVICE}" "${ZRAM_TEMP_MNT}"; then
    log_debug "ZRAM device mounted at ${ZRAM_TEMP_MNT}"
    
    # Copy filesystem from physical root to ZRAM ONLY if we successfully mounted physical root
    if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
        log_info "Copying root filesystem from ${REAL_ROOT_MNT} to ZRAM..."
        
        # Use the copy function with progress bar
        if copy_with_progress "${REAL_ROOT_MNT}" "${ZRAM_TEMP_MNT}"; then
            log_info "Filesystem copy completed successfully"
            
            # Create required directories in ZRAM root
            for dir in dev proc sys run tmp; do
                mkdir -p "${ZRAM_TEMP_MNT}/${dir}"
                chmod 755 "${ZRAM_TEMP_MNT}/${dir}"
            done
            
            # Modify /etc/fstab in ZRAM root
            if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
                log_debug "Backing up and modifying /etc/fstab in ZRAM root"
                cp "${ZRAM_TEMP_MNT}/etc/fstab" "${ZRAM_TEMP_MNT}/etc/fstab.zram_backup"
                
                # Create a temporary file for sed operations to avoid in-place editing issues
                temp_fstab="/tmp/fstab_temp.$$"
                
                # Comment out root filesystem entry
                sed 's|^\([^#].*[[:space:]]/[[:space:]].*\)$|# ZRAMROOT: \1|g' "${ZRAM_TEMP_MNT}/etc/fstab" > "$temp_fstab"
                
                # Comment out other mount points we want to disable in ZRAM
                sed 's|^\([^#].*[[:space:]]/boot[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab" > "$temp_fstab.2"
                sed 's|^\([^#].*[[:space:]]/boot/efi[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.2" > "$temp_fstab.3"
                sed 's|^\([^#].*[[:space:]]/home[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.3" > "$temp_fstab.4"
                sed 's|^\([^#].*[[:space:]]/var[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.4" > "$temp_fstab.5"
                
                # CRITICAL: Comment out swap partitions from original drive to prevent mounting
                # This ensures the original drive can be safely disconnected when using ZRAMroot
                sed 's|^\([^#].*[[:space:]]swap[[:space:]].*\)$|# ZRAMROOT-SWAP-DISABLED: \1|g' "$temp_fstab.5" > "$temp_fstab.6"
                
                log_debug "Disabled original drive swap partitions in ZRAM fstab"
                
                # Copy the final result back
                cp "$temp_fstab.6" "${ZRAM_TEMP_MNT}/etc/fstab"
                
                # Clean up temporary files
                rm -f "$temp_fstab" "$temp_fstab.2" "$temp_fstab.3" "$temp_fstab.4" "$temp_fstab.5" "$temp_fstab.6"
                
                log_debug "Successfully modified /etc/fstab"
                
                # Setup ZRAM swap if enabled
                if [ "${ZRAM_SWAP_ENABLED}" = "yes" ]; then
                    log_info "Setting up ZRAM swap..."
                    setup_zram_swap
                fi
            fi
        else
            log_error "Failed to copy files from physical root to ZRAM!"
            exit 1
        fi
    else
        log_debug "Physical root not mounted, assuming ZRAM already has filesystem"
    fi
    
    # Sync and unmount
    sync
    sleep 1
    umount "${ZRAM_TEMP_MNT}" || {
        log_error "Failed to unmount ZRAM root!"
        exit 1
    }
    log_debug "ZRAM root unmounted successfully"
else
    log_error "Failed to mount ZRAM device for file copy!"
    exit 1
fi

# Calculate final mount options
final_mount_opts=$(echo "${ZRAM_MOUNT_OPTS},rw" | sed 's/,defaults//g; s/,ro//g; s/,rw,rw/,rw/g; s/^,\|,$//g')
[ -z "$final_mount_opts" ] && final_mount_opts="rw"

# Export ZRAM variables for use by the local script
log_info "Setting ZRAMROOT Variables..."
export ZRAMROOT_DEVICE="${ZRAM_DEVICE}"
export ZRAMROOT_FSTYPE="${ZRAM_FS_TYPE}"
export ZRAMROOT_ROOTFLAGS="${final_mount_opts}"

mkdir -p /conf
echo "ZRAMROOT_DEVICE=${ZRAM_DEVICE}" > /conf/zramroot_vars
echo "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}" >> /conf/zramroot_vars
echo "ZRAMROOT_ROOTFLAGS=${final_mount_opts}" >> /conf/zramroot_vars
chmod 644 /conf/zramroot_vars

# Also write to tmp as backup
echo "ZRAMROOT_DEVICE=${ZRAM_DEVICE}" > /tmp/zramroot_vars
echo "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}" >> /tmp/zramroot_vars
echo "ZRAMROOT_ROOTFLAGS=${final_mount_opts}" >> /tmp/zramroot_vars

log_info "ZRAMROOT_DEVICE=${ZRAM_DEVICE}"
log_info "ZRAMROOT_FSTYPE=${ZRAM_FS_TYPE}"
log_info "ZRAMROOT_ROOTFLAGS=${final_mount_opts}"

# Final log entry
log_info "===== ZRAM ROOT PREPARATION SCRIPT FINISHED SUCCESSFULLY ====="

# --- LVM2 Cleanup Function ---
cleanup_lvm2() {
    # Check if LVM2 support is available
    if [ -f "/conf/lvm_support" ]; then
        . /conf/lvm_support
        if [ "${LVM_SUPPORT}" = "yes" ]; then
            log_info "Attempting to deactivate LVM2 volumes..."
            
            # Get the root device info to determine which VG to deactivate
            local root_dev="${REAL_ROOT_DEVICE}"
            local vg_name=""
            
            # Try to extract VG name from device path
            if echo "${root_dev}" | grep -q "/dev/mapper/"; then
                # Extract VG name from mapper path like /dev/mapper/vg0-root
                vg_name=$(echo "${root_dev}" | sed 's|/dev/mapper/\([^-]*\)-.*|\1|')
            elif echo "${root_dev}" | grep -q "/dev/.*/"; then
                # Extract VG name from LVM path like /dev/vg0/root
                vg_name=$(echo "${root_dev}" | sed 's|/dev/\([^/]*\)/.*|\1|')
            fi
            
            if [ -n "${vg_name}" ]; then
                log_debug "Detected volume group: ${vg_name}"
                
                # First try to deactivate the specific logical volume
                if command -v lvchange >/dev/null 2>&1; then
                    log_debug "Deactivating logical volume: ${root_dev}"
                    lvchange -an "${root_dev}" 2>/dev/null || true
                fi
                
                # Then try to deactivate the entire volume group
                if command -v vgchange >/dev/null 2>&1; then
                    log_debug "Deactivating volume group: ${vg_name}"
                    vgchange -an "${vg_name}" 2>/dev/null || true
                fi
                
                # Give it a moment to complete
                sleep 2
                
                log_info "LVM2 volume group '${vg_name}' deactivated"
            else
                log_debug "Could not determine volume group name from ${root_dev}"
                
                # Fallback: try to deactivate all volume groups
                if command -v vgchange >/dev/null 2>&1; then
                    log_debug "Attempting to deactivate all volume groups"
                    vgchange -an 2>/dev/null || true
                    sleep 2
                    log_info "All LVM2 volumes deactivated"
                fi
            fi
        else
            log_debug "LVM2 support not available - skipping LVM2 cleanup"
        fi
    else
        log_debug "No LVM2 support configuration found - skipping LVM2 cleanup"
    fi
}

# Cleanup physical root mount if we mounted it
if [ -d "${REAL_ROOT_MNT}" ] && mountpoint -q "${REAL_ROOT_MNT}"; then
    log_debug "Unmounting physical root"
    sync
    umount "${REAL_ROOT_MNT}" || umount -l "${REAL_ROOT_MNT}" || true
    
    # After unmounting, try to deactivate LVM2 volumes
    cleanup_lvm2
fi

exit 0
