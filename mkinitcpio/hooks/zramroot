#!/usr/bin/ash
# mkinitcpio hook for zramroot
# This is busybox ash, not bash - be careful with syntax!

run_hook() {
    # --- Check for Trigger Parameter ---
    CONFIG_FILE="/etc/zramroot.conf"

    # Defaults (will be overridden by config file)
    TRIGGER_PARAMETER="zramroot"

    # Load configuration
    if [ -f "${CONFIG_FILE}" ]; then
        . "${CONFIG_FILE}"
    fi

    # Use configured trigger parameter, default to "zramroot"
    local trigger="${TRIGGER_PARAMETER:-zramroot}"

    if ! grep -q "\b${trigger}\b" /proc/cmdline; then
        # Exit silently if trigger parameter not found
        return 0
    fi

    # --- Validate device number configuration ---
    if [ "$ZRAM_DEVICE_NUM" -eq "$ZRAM_SWAP_DEVICE_NUM" ] && [ "$ZRAM_SWAP_ENABLED" = "yes" ]; then
        echo "zramroot: ZRAM_DEVICE_NUM ($ZRAM_DEVICE_NUM) equals ZRAM_SWAP_DEVICE_NUM ($ZRAM_SWAP_DEVICE_NUM)"
        echo "zramroot: Automatically adjusting ZRAM_SWAP_DEVICE_NUM to $((ZRAM_SWAP_DEVICE_NUM + 1))"
        ZRAM_SWAP_DEVICE_NUM=$((ZRAM_SWAP_DEVICE_NUM + 1))
    fi

    # --- Global Variables ---
    DEBUG_MODE="no"
    DEBUG_LOG_DIR="/var/log"
    DEBUG_LOG_DEVICE=""
    ZRAM_SIZE_MiB=0
    ZRAM_ALGO="lz4"
    ZRAM_FS_TYPE="ext4"
    ZRAM_MOUNT_OPTS="noatime"
    RAM_MIN_FREE_MiB=512
    ZRAM_MIN_FREE_MiB=256
    RAM_PREF_FREE_MiB=1024
    ZRAM_MAX_FREE_MiB=35840
    ZRAM_BUFFER_PERCENT=10
    ZRAM_DEVICE_NUM=0
    ZRAM_SWAP_ENABLED="yes"
    ZRAM_SWAP_DEVICE_NUM=1
    ZRAM_SWAP_SIZE_MiB=0
    ZRAM_SWAP_ALGO="lz4"
    ZRAM_SWAP_PRIORITY=10
    ZRAM_TEMP_MNT="/zram_root"
    ZRAM_EXCLUDE_PATTERNS=""
    ZRAM_INCLUDE_PATTERNS=""
    ZRAM_MOUNT_ON_DISK=""
    ZRAM_PHYSICAL_ROOT_OPTS="rw"
    WAIT_TIMEOUT=120

    # Load configuration
    # Already loaded at start of hook, but reloading here ensures variable scope safety
    if [ -f "${CONFIG_FILE}" ]; then
        . "${CONFIG_FILE}"
    fi

    # Sanity-check debug log directory to avoid mounting over initramfs root
    if [ -z "${DEBUG_LOG_DIR}" ] || [ "${DEBUG_LOG_DIR}" = "/" ]; then
        DEBUG_LOG_DIR="/var/log"
    fi

    # Set compression ratio based on algorithm
    case "${ZRAM_ALGO}" in
        "zstd") ESTIMATED_COMPRESSION_RATIO=3.0 ;;
        "lz4hc") ESTIMATED_COMPRESSION_RATIO=2.5 ;;
        "lz4") ESTIMATED_COMPRESSION_RATIO=2.0 ;;
        "lzo"|"lzo-rle") ESTIMATED_COMPRESSION_RATIO=1.8 ;;
        *) ESTIMATED_COMPRESSION_RATIO=2.2 ;;
    esac

    # --- Persistent Logging Setup ---
    REAL_ROOT_MNT="/mnt/real_root_rw"
    DATE_TIME=$(date '+%Y%m%d-%H%M%S' 2>/dev/null || echo "unknown")
    REAL_ROOT_LOG_DIR="${REAL_ROOT_MNT}${DEBUG_LOG_DIR}"
    REAL_ROOT_LOG_FILE="${REAL_ROOT_LOG_DIR}/zramroot-${DATE_TIME}.log"

    update_log_paths() {
        if [ -n "${DEBUG_LOG_DEVICE}" ]; then
            mkdir -p "${DEBUG_LOG_DIR}" 2>/dev/null || true
            if ! mountpoint -q "${DEBUG_LOG_DIR}" 2>/dev/null; then
                # Use -t auto for automatic filesystem detection
                mount -t auto -o rw "${DEBUG_LOG_DEVICE}" "${DEBUG_LOG_DIR}" 2>/dev/null || true
            fi
            REAL_ROOT_LOG_DIR="${DEBUG_LOG_DIR}"
        else
            REAL_ROOT_LOG_DIR="${REAL_ROOT_MNT}${DEBUG_LOG_DIR}"
        fi
        REAL_ROOT_LOG_FILE="${REAL_ROOT_LOG_DIR}/zramroot-${DATE_TIME}.log"
    }

    # Apply configured log paths immediately
    update_log_paths

    # Function to ensure physical root is mounted for logging
    ensure_physical_root_mounted() {
        # If a dedicated log device is configured, prefer it
        if [ -n "${DEBUG_LOG_DEVICE}" ]; then
            update_log_paths
            if [ -w "${REAL_ROOT_LOG_DIR}" ]; then
                touch "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
                return 0
            fi
        fi

        # Only attempt if not already mounted
        if [ ! -d "${REAL_ROOT_MNT}" ] || ! mountpoint -q "${REAL_ROOT_MNT}" 2>/dev/null; then
            mkdir -p "${REAL_ROOT_MNT}"

            # Try to get the original root device
            local orig_root="${root}"

            if [ -n "$orig_root" ] && [ -b "$orig_root" ]; then
                # Try to mount the physical root
                if mount -o rw "$orig_root" "${REAL_ROOT_MNT}" 2>/dev/null; then
                    update_log_paths
                    mkdir -p "${REAL_ROOT_LOG_DIR}"
                    touch "${REAL_ROOT_LOG_FILE}" 2>/dev/null || true
                    return 0
                fi
            fi
        fi
        return 0
    }

    # --- Logging Functions ---
    log_kernel() {
        echo "zramroot: $*" > /dev/kmsg 2>/dev/null || true
    }

    log_to_file() {
        local MSG="$*"

        # Only log to file if DEBUG_MODE=yes or this is an error message
        if [ "${DEBUG_MODE}" = "yes" ] || echo "$MSG" | grep -q "ERROR"; then
            # Ensure physical root is mounted for logging
            ensure_physical_root_mounted

            if [ -w "${REAL_ROOT_LOG_FILE}" ]; then
                local now=""
                if command -v date >/dev/null 2>&1; then
                    now="$(date '+%Y-%m-%d %H:%M:%S')"
                fi
                echo "${now} $MSG" >> "${REAL_ROOT_LOG_FILE}"
            fi
        fi
    }

    log_info() {
        log_kernel "$*"
        log_to_file "INFO: $*"
        [ "${DEBUG_MODE}" = "yes" ] && echo "zramroot: $*"
    }

    log_error() {
        log_kernel "ERROR: $*"
        log_to_file "ERROR: $*"
        echo "zramroot: ERROR: $*"
    }

    log_debug() {
        if [ "${DEBUG_MODE}" = "yes" ]; then
            log_kernel "DEBUG: $*"
            log_to_file "DEBUG: $*"
            echo "zramroot: DEBUG: $*"
        fi
    }

    # --- Device Polling Function ---
    poll_device() {
        local device="$1"
        local timeout="${2:-120}"
        local elapsed=0

        log_debug "Waiting for device $device (timeout: ${timeout}s)"

        while [ $elapsed -lt $timeout ]; do
            if [ -b "$device" ]; then
                log_debug "Device $device available after ${elapsed}s"
                return 0
            fi
            sleep 1
            elapsed=$((elapsed + 1))
            if [ $((elapsed % 10)) -eq 0 ]; then
                log_debug "Still waiting for $device... (${elapsed}s/${timeout}s)"
            fi
        done

        log_error "Device $device not available after ${timeout}s"
        return 1
    }

    # --- Graceful Fallback Function ---
    # When ZRAM setup fails, this allows normal boot to continue
    ZRAMROOT_FALLBACK_TRIGGERED="no"

    fallback_to_normal_boot() {
        local reason="$1"

        if [ "${ZRAMROOT_FALLBACK_TRIGGERED}" = "yes" ]; then
            return 0
        fi
        ZRAMROOT_FALLBACK_TRIGGERED="yes"

        log_error "ZRAM setup failed: $reason"
        log_error "Falling back to normal boot (zramroot disabled)"

        # Clean up any partial mounts
        umount "${ZRAM_TEMP_MNT}" 2>/dev/null || true
        umount /local_root 2>/dev/null || true
        umount /mnt/physical_root 2>/dev/null || true

        # Reset ZRAM device if it was partially set up
        if [ -n "$zram_device" ] && [ -e "/sys/block/$(basename $zram_device)/reset" ]; then
            echo 1 > "/sys/block/$(basename $zram_device)/reset" 2>/dev/null || true
        fi

        # Do NOT modify root variable - let mkinitcpio use original root
        # By returning 0, we allow the boot to continue normally
        return 0
    }

    # --- Progress Bar Functions ---
    ESC='\033'
    CLEAR_LINE="${ESC}[2K\r"
    GREEN="${ESC}[0;32m"
    YELLOW="${ESC}[1;33m"
    BLUE="${ESC}[0;34m"
    NC="${ESC}[0m"

    draw_parallel_progress_bar() {
        local percentage=$1
        local total_threads=$2
        local active_threads=${3:-$total_threads}
        local bar_width=50
        local filled=$((percentage * bar_width / 100))
        local empty=$((bar_width - filled))

        # Create the bar
        local bar=""
        local i=0

        while [ $i -lt $filled ]; do
            bar="${bar}█"
            i=$((i + 1))
        done

        i=0
        while [ $i -lt $empty ]; do
            bar="${bar}░"
            i=$((i + 1))
        done

        printf "\r${BLUE}[${GREEN}${bar}${BLUE}] ${GREEN}%3d%%${NC} ${YELLOW}[%d/%d threads]${NC} Copying...     " "$percentage" "$active_threads" "$total_threads"
    }

    # --- Build rsync filters from configuration ---
    build_rsync_filters() {
        local filters=""

        # Add include patterns first (they take precedence)
        if [ -n "$ZRAM_INCLUDE_PATTERNS" ]; then
            log_debug "Processing include patterns: $ZRAM_INCLUDE_PATTERNS"
            for pattern in $ZRAM_INCLUDE_PATTERNS; do
                filters="$filters --include=$pattern"
                log_debug "  Include: $pattern"
            done
        fi

        # Add mount-on-disk paths to exclude patterns
        local exclude_patterns="$ZRAM_EXCLUDE_PATTERNS"
        if [ -n "$ZRAM_MOUNT_ON_DISK" ]; then
            log_debug "Adding mount-on-disk paths to exclusions: $ZRAM_MOUNT_ON_DISK"
            for mount_path in $ZRAM_MOUNT_ON_DISK; do
                mount_path=$(echo "$mount_path" | sed 's:^/::; s:/$::')
                if [ -n "$mount_path" ]; then
                    exclude_patterns="$exclude_patterns /$mount_path /$mount_path/*"
                    log_debug "  Excluding (will bind-mount): /$mount_path"
                fi
            done
        fi

        # Add exclude patterns
        if [ -n "$exclude_patterns" ]; then
            log_debug "Processing exclude patterns: $exclude_patterns"
            for pattern in $exclude_patterns; do
                filters="$filters --exclude=$pattern"
                log_debug "  Exclude: $pattern"
            done
        fi

        echo "$filters"
    }

    # --- Detect Optimal Thread Count ---
    detect_optimal_threads() {
        local cpu_cores
        cpu_cores=$(nproc 2>/dev/null || echo "1")
        local available_ram_mb
        available_ram_mb=$(($(awk '/MemAvailable/ {print $2}' /proc/meminfo) / 1024))

        local optimal_threads=$cpu_cores
        local max_ram_threads=$((available_ram_mb / 75))

        if [ "$max_ram_threads" -lt "$optimal_threads" ]; then
            optimal_threads=$max_ram_threads
        fi

        if [ "$optimal_threads" -lt 1 ]; then
            optimal_threads=1
        elif [ "$optimal_threads" -gt 16 ]; then
            optimal_threads=16
        fi

        log_debug "Using ${optimal_threads} parallel operations"
        echo "$optimal_threads"
    }

    # --- Helper to check if directory is a top-level mount-on-disk path ---
    # Only returns true for exact top-level matches (e.g., "home" matches "/home")
    # Does NOT return true for parent directories (e.g., "var" does NOT match "/var/lib/docker")
    # This is because rsync handles nested excludes correctly, but work distribution
    # should only skip top-level directories that are entirely excluded
    is_excluded_top_level_dir() {
        local check_path="$1"
        if [ -z "$ZRAM_MOUNT_ON_DISK" ]; then
            return 1
        fi
        for mount_path in $ZRAM_MOUNT_ON_DISK; do
            # Normalize: remove leading/trailing slashes
            mount_path=$(echo "$mount_path" | sed 's:^/::; s:/$::')
            # Only match if it's exactly the top-level directory (no slashes in path)
            # e.g., "home" matches "/home", but "var" does NOT match "/var/lib/docker"
            if [ "$check_path" = "$mount_path" ]; then
                return 0
            fi
        done
        return 1
    }

    # --- Work Distribution for Parallel Copy ---
    create_work_distribution() {
        local source="$1"
        local thread_count="$2"
        local work_dir="/tmp/parallel_rsync_work"

        mkdir -p "$work_dir"
        rm -f "${work_dir}/job_"*

        local dir_list="${work_dir}/directories.list"

        # Get subdirectories, excluding special ones and mount-on-disk paths
        find "$source" -maxdepth 1 -type d ! -path "$source" \
            ! -name "dev" ! -name "proc" ! -name "sys" ! -name "tmp" \
            ! -name "run" ! -name "mnt" ! -name "media" ! -name "lost+found" \
            2>/dev/null | while read dir; do
            if [ -d "$dir" ]; then
                local dir_name
                dir_name=$(basename "$dir")

                # Skip directories that are top-level mount-on-disk paths
                if is_excluded_top_level_dir "$dir_name"; then
                    log_debug "Skipping mount-on-disk directory from work distribution: $dir_name"
                    continue
                fi

                local size_kb
                size_kb=$(du -sk "$dir" 2>/dev/null | awk '{print $1}' || echo "0")
                echo "${size_kb}:${dir_name}" >> "$dir_list"
            fi
        done

        # Sort by size (largest first)
        sort -rn -t: -k1 "$dir_list" > "${dir_list}.sorted"

        # Initialize job files
        local i=0
        while [ $i -lt $thread_count ]; do
            echo "0" > "${work_dir}/job_${i}.size"
            touch "${work_dir}/job_${i}.list"
            i=$((i + 1))
        done

        # Distribute directories using load balancing
        while read line; do
            if [ -n "$line" ]; then
                local size
                size=$(echo "$line" | cut -d: -f1)
                local dir_name
                dir_name=$(echo "$line" | cut -d: -f2)

                # Find job with minimum size
                local min_job=0
                local min_size
                min_size=$(cat "${work_dir}/job_0.size")

                i=1
                while [ $i -lt $thread_count ]; do
                    local current_size
                    current_size=$(cat "${work_dir}/job_${i}.size")
                    if [ "$current_size" -lt "$min_size" ]; then
                        min_size=$current_size
                        min_job=$i
                    fi
                    i=$((i + 1))
                done

                # Add to job with minimum size
                echo "$dir_name" >> "${work_dir}/job_${min_job}.list"
                local new_size=$((min_size + size))
                echo "$new_size" > "${work_dir}/job_${min_job}.size"
            fi
        done < "${dir_list}.sorted"

        # Add root files to job 0
        echo "ROOT_FILES" >> "${work_dir}/job_0.list"

        echo "$work_dir"
    }

    # --- Parallel Copy with Progress ---
    copy_with_parallel_progress() {
        local source="$1"
        local dest="$2"

        log_info "Starting parallel copy from ${source} to ${dest}"

        local thread_count
        thread_count=$(detect_optimal_threads)

        local total_kb
        total_kb=$(du -sk "$source" 2>/dev/null | awk '{print $1}')

        if [ -z "$total_kb" ] || [ "$total_kb" -eq 0 ]; then
            log_error "Could not determine source size"
            return 1
        fi

        log_debug "Total size: ${total_kb} KB"

        local work_dir
        work_dir=$(create_work_distribution "$source" "$thread_count")

        # Build user-configured filters
        # Note: rsync processes filters in order, so includes must come before excludes
        local USER_FILTERS
        USER_FILTERS=$(build_rsync_filters)
        local DEFAULT_EXCLUDES="--exclude=/dev/* --exclude=/proc/* --exclude=/sys/* --exclude=/tmp/* --exclude=/run/* --exclude=/mnt/* --exclude=/media/* --exclude=/lost+found --exclude=/var/log/journal/*"

        # User filters (includes first, then user excludes) come before default excludes
        if [ -n "$USER_FILTERS" ]; then
            log_info "Applying user-configured include/exclude filters"
            RSYNC_EXCLUDE="$USER_FILTERS $DEFAULT_EXCLUDES"
        else
            RSYNC_EXCLUDE="$DEFAULT_EXCLUDES"
        fi

        # Display header
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "    Copying to ZRAM (${thread_count} parallel operations)"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""

        draw_parallel_progress_bar 0 "$thread_count"

        # Start rsync jobs in parallel
        local i=0
        while [ $i -lt $thread_count ]; do
            local job_file="${work_dir}/job_${i}.list"
            local job_log="${work_dir}/job_${i}.log"

            if [ -s "$job_file" ]; then
                (
                    while read item; do
                        rsync_exit=1
                        retry_count=0
                        max_retries=3

                        while [ $rsync_exit -ne 0 ] && [ $retry_count -lt $max_retries ]; do
                            if [ "$item" = "ROOT_FILES" ]; then
                                # shellcheck disable=SC2086
                                rsync -ax \
                                      --include="/*" --exclude="/*/" \
                                      --exclude="/dev" --exclude="/proc" --exclude="/sys" \
                                      --exclude="/tmp" --exclude="/run" --exclude="/mnt" \
                                      --exclude="/media" --exclude="/lost+found" \
                                      $USER_FILTERS \
                                      "${source}/" "${dest}/" 2>>"$job_log"
                                rsync_exit=$?
                            else
                                mkdir -p "${dest}/${item}"
                                # shellcheck disable=SC2086
                                rsync -ax --delete \
                                      $RSYNC_EXCLUDE \
                                      "${source}/${item}/" "${dest}/${item}/" 2>>"$job_log"
                                rsync_exit=$?
                            fi

                            if [ $rsync_exit -ne 0 ]; then
                                retry_count=$((retry_count + 1))
                                if [ $retry_count -lt $max_retries ]; then
                                    echo "Retry $retry_count/$max_retries for $item" >> "$job_log"
                                    sleep 1
                                else
                                    echo "FAILED after $max_retries retries: $item (exit code: $rsync_exit)" >> "$job_log"
                                fi
                            fi
                        done
                    done < "$job_file"
                ) &

                local job_pid=$!
                echo "$job_pid" > "${work_dir}/job_${i}.pid"
                log_debug "Started job $i with PID $job_pid"
            fi
            i=$((i + 1))
        done

        # Monitor progress
        local last_percentage=0
        local max_wait=1800
        local elapsed=0

        while [ $elapsed -lt $max_wait ]; do
            local running_jobs=0

            i=0
            while [ $i -lt $thread_count ]; do
                local pid_file="${work_dir}/job_${i}.pid"
                if [ -f "$pid_file" ]; then
                    local job_pid
                    job_pid=$(cat "$pid_file")
                    if [ -n "$job_pid" ] && kill -0 "$job_pid" 2>/dev/null; then
                        running_jobs=$((running_jobs + 1))
                    fi
                fi
                i=$((i + 1))
            done

            if [ $running_jobs -eq 0 ]; then
                break
            fi

            # Calculate progress
            local current_kb
            current_kb=$(du -sk "$dest" 2>/dev/null | awk '{print $1}')

            if [ -n "$current_kb" ] && [ "$current_kb" -gt 0 ]; then
                local current_percentage=$((current_kb * 100 / total_kb))

                if [ "$current_percentage" -gt 99 ] && [ $running_jobs -gt 0 ]; then
                    current_percentage=99
                fi

                if [ "$current_percentage" -ne "$last_percentage" ]; then
                    draw_parallel_progress_bar "$current_percentage" "$thread_count" "$running_jobs"
                    last_percentage=$current_percentage
                fi
            fi

            sleep 2
            elapsed=$((elapsed + 2))
        done

        # Wait for remaining jobs
        local overall_exit=0
        i=0
        while [ $i -lt $thread_count ]; do
            local pid_file="${work_dir}/job_${i}.pid"
            if [ -f "$pid_file" ]; then
                local job_pid
                job_pid=$(cat "$pid_file")
                if [ -n "$job_pid" ]; then
                    wait "$job_pid"
                    local job_exit=$?
                    if [ $job_exit -ne 0 ]; then
                        overall_exit=$job_exit
                    fi
                fi
            fi
            i=$((i + 1))
        done

        # Show 100%
        draw_parallel_progress_bar 100 "$thread_count" 0
        echo ""
        echo ""

        log_info "Parallel copy completed"

        rm -rf "$work_dir"

        return $overall_exit
    }

    # --- ZRAM Swap Setup ---
    setup_zram_swap() {
        log_debug "Setting up ZRAM swap device ${ZRAM_SWAP_DEVICE_NUM}"

        local swap_size_mib="${ZRAM_SWAP_SIZE_MiB}"
        if [ "$swap_size_mib" -eq 0 ]; then
            local total_ram_kb
            total_ram_kb=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
            local total_ram_mib=$((total_ram_kb / 1024))

            swap_size_mib=$((total_ram_mib / 4))
            [ "$swap_size_mib" -gt 4096 ] && swap_size_mib=4096
            [ "$swap_size_mib" -lt 512 ] && swap_size_mib=512

            log_debug "Auto-calculated swap size: ${swap_size_mib} MiB"
        fi

        local zram_swap_device="/dev/zram${ZRAM_SWAP_DEVICE_NUM}"

        if [ ! -b "$zram_swap_device" ]; then
            if command -v zramctl >/dev/null 2>&1; then
                zramctl --find --size "${swap_size_mib}M" --algorithm "${ZRAM_SWAP_ALGO}" >/dev/null 2>&1 || {
                    echo "${ZRAM_SWAP_ALGO}" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
                    echo "${swap_size_mib}M" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/disksize 2>/dev/null
                }
            else
                echo "${ZRAM_SWAP_ALGO}" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
                echo "${swap_size_mib}M" > /sys/class/block/zram${ZRAM_SWAP_DEVICE_NUM}/disksize 2>/dev/null
            fi
        fi

        sleep 2

        if [ ! -b "$zram_swap_device" ]; then
            log_error "ZRAM swap device does not exist"
            return 1
        fi

        if mkswap "$zram_swap_device" >/dev/null 2>&1; then
            log_info "ZRAM swap created (${swap_size_mib} MiB)"

            if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
                echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                echo "# ZRAM Swap" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                echo "$zram_swap_device none swap sw,pri=${ZRAM_SWAP_PRIORITY} 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            fi

            return 0
        else
            log_error "Failed to create swap on $zram_swap_device"
            return 1
        fi
    }

    # =================================================================
    # MAIN EXECUTION STARTS HERE
    # =================================================================

    log_info "=== STARTING ZRAM ROOT SETUP PROCESS ==="

    # Check available RAM
    AVAILABLE_RAM_KB=$(awk '/MemAvailable/ {print $2}' /proc/meminfo)
    [ -z "$AVAILABLE_RAM_KB" ] && AVAILABLE_RAM_KB=$(awk '/MemFree/ {print $2}' /proc/meminfo)

    if [ -z "$AVAILABLE_RAM_KB" ]; then
        fallback_to_normal_boot "Cannot determine available RAM"
        return 0
    fi

    AVAILABLE_RAM_MiB=$((AVAILABLE_RAM_KB / 1024))
    log_info "Available RAM: ${AVAILABLE_RAM_MiB} MiB"

    # Validate root device is set
    if [ -z "$root" ]; then
        fallback_to_normal_boot "Root device not set by mkinitcpio"
        return 0
    fi

    log_info "Root device: $root"

    # Mount root device to calculate size
    mkdir -p /local_root
    if ! poll_device "$root" "$WAIT_TIMEOUT"; then
        fallback_to_normal_boot "Root device $root not available"
        return 0
    fi

    if ! mount "$root" /local_root; then
        fallback_to_normal_boot "Failed to mount root device $root"
        return 0
    fi

    ROOT_USED_KB=$(df -k /local_root | awk 'NR==2 {print $3}')
    ROOT_USED_MiB=$((ROOT_USED_KB / 1024))
    log_info "Used size on physical root: ${ROOT_USED_MiB} MiB"

    # Add buffer
    BUFFER_MiB=$((ROOT_USED_MiB * ZRAM_BUFFER_PERCENT / 100))
    ROOT_WITH_BUFFER_MiB=$((ROOT_USED_MiB + BUFFER_MiB))

    # Calculate expected compressed size
    EXPECTED_COMPRESSED_ROOT_MiB=$(awk -v r="$ROOT_WITH_BUFFER_MiB" -v c="$ESTIMATED_COMPRESSION_RATIO" 'BEGIN{printf "%.0f", r / c}')
    log_info "Expected compressed size: ${EXPECTED_COMPRESSED_ROOT_MiB} MiB (ratio: ${ESTIMATED_COMPRESSION_RATIO})"

    # Determine ZRAM size
    if [ "$ZRAM_SIZE_MiB" -gt 0 ]; then
        FINAL_ZRAM_SIZE_MiB=$ZRAM_SIZE_MiB
        log_info "Using configured ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    else
        # Calculate dynamically
        if [ $((AVAILABLE_RAM_MiB - RAM_MIN_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
            fallback_to_normal_boot "Insufficient RAM for ZRAM root"
            return 0
        fi

        if [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MIN_FREE_MiB)) -le 0 ]; then
            FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MIN_FREE_MiB))
        elif [ $((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB - ZRAM_MAX_FREE_MiB)) -le 0 ]; then
            EXTRA_ZRAM=$((AVAILABLE_RAM_MiB - RAM_PREF_FREE_MiB - EXPECTED_COMPRESSED_ROOT_MiB))
            FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + EXTRA_ZRAM))
        else
            FINAL_ZRAM_SIZE_MiB=$((EXPECTED_COMPRESSED_ROOT_MiB + ZRAM_MAX_FREE_MiB))
        fi

        MIN_SAFE_ZRAM=$((EXPECTED_COMPRESSED_ROOT_MiB + (EXPECTED_COMPRESSED_ROOT_MiB / 4)))
        if [ "$FINAL_ZRAM_SIZE_MiB" -lt "$MIN_SAFE_ZRAM" ]; then
            FINAL_ZRAM_SIZE_MiB=$MIN_SAFE_ZRAM
        fi

        log_info "Auto-calculated ZRAM size: ${FINAL_ZRAM_SIZE_MiB} MiB"
    fi

    # Load zram module
    if ! lsmod | grep -q '^zram '; then
        modprobe zram || {
            fallback_to_normal_boot "Failed to load zram module"
            return 0
        }
    fi

    # Wait for ZRAM control interface with polling
    log_info "Waiting for ZRAM control interface..."
    local zram_wait=0
    local zram_max_wait=30
    while [ $zram_wait -lt $zram_max_wait ]; do
        if [ -e /sys/class/zram-control ] || [ -e "/sys/block/zram${ZRAM_DEVICE_NUM}" ]; then
            log_debug "ZRAM control interface available after ${zram_wait}s"
            break
        fi
        sleep 1
        zram_wait=$((zram_wait + 1))
        if [ $((zram_wait % 5)) -eq 0 ]; then
            log_debug "Still waiting for ZRAM control interface... (${zram_wait}s/${zram_max_wait}s)"
        fi
    done

    if [ ! -e /sys/class/zram-control ] && [ ! -e "/sys/block/zram${ZRAM_DEVICE_NUM}" ]; then
        fallback_to_normal_boot "ZRAM control interface not available after ${zram_max_wait}s"
        return 0
    fi

    # Create ZRAM device
    zram_device=""
    if command -v zramctl >/dev/null 2>&1; then
        zram_device=$(zramctl --find --size "${FINAL_ZRAM_SIZE_MiB}M" --algorithm "${ZRAM_ALGO}" 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$zram_device" ]; then
            log_debug "zramctl failed, using manual approach"
            zram_device="/dev/zram${ZRAM_DEVICE_NUM}"
            echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
            echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
        fi
    else
        zram_device="/dev/zram${ZRAM_DEVICE_NUM}"
        echo "${ZRAM_ALGO}" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/comp_algorithm 2>/dev/null || true
        echo "${FINAL_ZRAM_SIZE_MiB}M" > /sys/class/block/zram${ZRAM_DEVICE_NUM}/disksize 2>/dev/null
    fi

    # Wait for ZRAM device to be ready with polling
    log_debug "Waiting for ZRAM device $zram_device to be ready..."
    local zram_dev_wait=0
    local zram_dev_max_wait=30
    while [ $zram_dev_wait -lt $zram_dev_max_wait ]; do
        if [ -b "$zram_device" ]; then
            log_debug "ZRAM device $zram_device ready after ${zram_dev_wait}s"
            break
        fi
        sleep 1
        zram_dev_wait=$((zram_dev_wait + 1))
        if [ $((zram_dev_wait % 5)) -eq 0 ]; then
            log_debug "Still waiting for $zram_device... (${zram_dev_wait}s/${zram_dev_max_wait}s)"
        fi
    done

    if [ ! -b "$zram_device" ]; then
        fallback_to_normal_boot "ZRAM device $zram_device not available after ${zram_dev_max_wait}s"
        return 0
    fi

    log_info "ZRAM device created: $zram_device"

    # Format ZRAM device
    mkfs_cmd="mkfs.${ZRAM_FS_TYPE}"
    mkfs_opts=""

    # Check if mkfs command exists
    if ! command -v ${mkfs_cmd} >/dev/null 2>&1; then
        case "${ZRAM_FS_TYPE}" in
            ext4)
                log_error "mkfs.ext4 not found in initramfs! Install e2fsprogs and run: sudo mkinitcpio -P"
                ;;
            btrfs)
                log_error "mkfs.btrfs not found in initramfs! Install btrfs-progs and run: sudo mkinitcpio -P"
                ;;
            xfs)
                log_error "mkfs.xfs not found in initramfs! Install xfsprogs and run: sudo mkinitcpio -P"
                ;;
            *)
                log_error "Filesystem utility ${mkfs_cmd} not found in initramfs!"
                ;;
        esac
        fallback_to_normal_boot "Filesystem utility ${mkfs_cmd} not found"
        return 0
    fi

    if [ "$ZRAM_FS_TYPE" = "ext4" ]; then
        mkfs_opts="-F"
    elif [ "$ZRAM_FS_TYPE" = "btrfs" ]; then
        mkfs_opts="-f"
    elif [ "$ZRAM_FS_TYPE" = "xfs" ]; then
        mkfs_opts="-f"
    fi

    if ! ${mkfs_cmd} ${mkfs_opts} "$zram_device" >/dev/null 2>&1; then
        fallback_to_normal_boot "Failed to format ZRAM device with ${ZRAM_FS_TYPE}"
        return 0
    fi

    log_info "ZRAM device formatted with ${ZRAM_FS_TYPE}"

    # Mount ZRAM device
    mkdir -p "${ZRAM_TEMP_MNT}"
    if ! mount -t "${ZRAM_FS_TYPE}" -o "rw,${ZRAM_MOUNT_OPTS}" "$zram_device" "${ZRAM_TEMP_MNT}"; then
        fallback_to_normal_boot "Failed to mount ZRAM device"
        return 0
    fi

    # Copy filesystem to ZRAM with parallel progress
    log_info "Copying root filesystem to ZRAM..."
    if ! copy_with_parallel_progress /local_root "${ZRAM_TEMP_MNT}"; then
        fallback_to_normal_boot "Failed to copy filesystem to ZRAM"
        return 0
    fi

    # Create required directories
    for dir in dev proc sys run tmp; do
        mkdir -p "${ZRAM_TEMP_MNT}/${dir}"
        chmod 755 "${ZRAM_TEMP_MNT}/${dir}"
    done

    # Modify /etc/fstab
    if [ -f "${ZRAM_TEMP_MNT}/etc/fstab" ]; then
        cp "${ZRAM_TEMP_MNT}/etc/fstab" "${ZRAM_TEMP_MNT}/etc/fstab.zram_backup"

        # Use temporary files for sed (busybox compatible)
        temp_fstab="/tmp/fstab_temp.$$"

        sed 's|^\([^#].*[[:space:]]/[[:space:]].*\)$|# ZRAMROOT: \1|g' "${ZRAM_TEMP_MNT}/etc/fstab" > "$temp_fstab"
        sed 's|^\([^#].*[[:space:]]/boot[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab" > "$temp_fstab.2"
        sed 's|^\([^#].*[[:space:]]/boot/efi[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.2" > "$temp_fstab.3"
        sed 's|^\([^#].*[[:space:]]/home[[:space:]].*\)$|# ZRAMROOT: \1|g' "$temp_fstab.3" > "$temp_fstab.4"
        sed 's|^\([^#].*[[:space:]]swap[[:space:]].*\)$|# ZRAMROOT-SWAP-DISABLED: \1|g' "$temp_fstab.4" > "$temp_fstab.5"

        cp "$temp_fstab.5" "${ZRAM_TEMP_MNT}/etc/fstab"
        rm -f "$temp_fstab" "$temp_fstab.2" "$temp_fstab.3" "$temp_fstab.4" "$temp_fstab.5"

        log_debug "Modified /etc/fstab"

        # Setup mount-on-disk bind mounts if configured
        if [ -n "$ZRAM_MOUNT_ON_DISK" ]; then
            log_info "Configuring mount-on-disk directories..."

            # Add the physical root mount itself to fstab so systemd/init knows about it
            echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            echo "# ZRAMROOT: Physical root mount (required for bind mounts)" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            local phys_opts="${ZRAM_PHYSICAL_ROOT_OPTS:-rw}"
            echo "${root} /mnt/physical_root auto ${phys_opts},nofail 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
            log_debug "Added physical root mount entry to /etc/fstab: ${root} -> /mnt/physical_root"

            for mount_path in $ZRAM_MOUNT_ON_DISK; do
                mount_path=$(echo "$mount_path" | sed 's:^/::; s:/$::')

                if [ -z "$mount_path" ]; then
                    continue
                fi

                if [ -d "/local_root/${mount_path}" ]; then
                    mkdir -p "${ZRAM_TEMP_MNT}/${mount_path}"
                    log_debug "Created mount point /${mount_path} in ZRAM root"

                    echo "" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                    echo "# ZRAMROOT: Bind mount from physical disk" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                    echo "/mnt/physical_root/${mount_path} /${mount_path} none bind 0 0" >> "${ZRAM_TEMP_MNT}/etc/fstab"
                    log_info "Added bind mount for /${mount_path} from physical disk"
                else
                    log_error "Warning: Mount-on-disk path /${mount_path} does not exist - skipping"
                fi
            done

            ZRAMROOT_KEEP_PHYSICAL_MOUNTED="yes"
        fi
    fi

    # Setup ZRAM swap if enabled
    if [ "${ZRAM_SWAP_ENABLED}" = "yes" ]; then
        log_info "Setting up ZRAM swap..."
        setup_zram_swap
    fi

    # Unmount physical root (or remount for bind mounts)
    sync
    if [ "${ZRAMROOT_KEEP_PHYSICAL_MOUNTED}" = "yes" ]; then
        log_info "Keeping physical root for bind mounts at /mnt/physical_root"

        # Get the original root device
        local orig_root="${root}"

        # Unmount from /local_root
        umount /local_root 2>/dev/null || true

        # Create mount point for physical root
        mkdir -p /mnt/physical_root

        # Mount at final location with configured options
        local phys_mount_opts="${ZRAM_PHYSICAL_ROOT_OPTS:-rw}"
        log_debug "Mounting physical root with options: ${phys_mount_opts}"

        if mount -o "${phys_mount_opts}" "$orig_root" /mnt/physical_root 2>/dev/null; then
            log_info "Physical root mounted at /mnt/physical_root"
        else
            log_error "Failed to mount physical root - bind mounts will not work!"
        fi
    else
        umount /local_root
    fi

    # Unmount ZRAM temporarily
    sync
    umount "${ZRAM_TEMP_MNT}"

    # Unmount persistent logging root if it was mounted
    if mountpoint -q "${REAL_ROOT_MNT}" 2>/dev/null; then
        log_debug "Unmounting persistent log mount"
        sync
        umount "${REAL_ROOT_MNT}" 2>/dev/null || true
    fi

    log_info "ZRAM root setup completed successfully"

    # Update root variable to point to ZRAM device
    # This is critical - tells mkinitcpio the new root device
    root=$zram_device

    # Export variables needed by mount handler
    export zram_device
    export ZRAM_FS_TYPE
    export ZRAM_MOUNT_OPTS
    export root

    # Set the mount handler for mkinitcpio
    export mount_handler=zram_mount
}

# Define mount handler in global scope (outside run_hook)
# This function is called by mkinitcpio's init to mount the root filesystem
zram_mount() {
    mount -t "${ZRAM_FS_TYPE}" -o "rw,${ZRAM_MOUNT_OPTS}" "$zram_device" "$1"

    # If we kept physical root mounted, we need to move it to the new root
    if [ -d "/mnt/physical_root" ] && mountpoint -q "/mnt/physical_root"; then
        # Create destination directory in the new root
        mkdir -p "$1/mnt/physical_root"

        # Move the mount
        mount --move "/mnt/physical_root" "$1/mnt/physical_root"
    fi
}

# Disable fsck for ZRAM device (called by mkinitcpio's init)
fsck_root() {
    :
}
